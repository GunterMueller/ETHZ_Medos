A c11.  Library ModulesC Y15 c15.5.82, rev. 27.9.82+This chapter is a collection of some commonly used library modules on Lilith.  For each library module a 1symbol file0 and an 1object file0 is stored on the disk cartridge.  The file names are derived from (the first 16 characters of) the module name, beginning with the prefix 7LIB0 and ending with the extension 7SYM0 for symbol files and the extension 7OBJ0 for object files.  It is possible that some object files are pre-linked and therefore also contain the code of the imported modules.x25 t210.Module name  7FileNames0Symbol file name  7DK.LIB.FileNames.SYM0Object file name  7DK.LIB.FileNames.OBJ0+ w15List of the Library Modulesx25 t170 450.InOut  Simple handling of formatted input/output  11.1.RealInOut  Formatted input/output of real numbers  11.2.Mouse  Mouse handling and cursor tracking  11.3.LineDrawing  Line drawing on the screen  11.4.MathLib0  Basic mathematical functions  11.5.OutTerminal  Formatted output to the terminal  11.6.OutFile  Formatted output to files  11.7.OutWindow  Formatted output to windows  11.8.ByteIO  Input/output of bytes on files  11.9.ByteBlockIO  Input/output of byte blocks on files  11.10.FileNames  Input of file names from the terminal  11.11.Options  Input of program options and file names  11.12.Line  Driver for the RS-232 (V24) line interface  11.13.V24  Driver for the RS-232 (V24) line interface  11.14.String  String handling  11.15.+ w15The first four modules are considered to be used by small programs and for introductory exercises.  They provide access to the terminal and to files, to the mouse, and to the screen by a simple interface.p B11.1.  InOut+Niklaus Wirth  15.5.82, rev. 20.6.82Library module for formatted input/output on terminal or files.  A description of this module is included to the Modula-2 manual [1].w151Imported Library Modules0x25 nTerminalFileSystem+ w151Definition Module0= x25DEFINITION MODULE InOut;    (*NW 20.6.82*)  FROM SYSTEM IMPORT WORD;  FROM FileSystem IMPORT File;  EXPORT QUALIFIED    EOL, Done, in, out, termCH,    OpenInput, OpenOutput, CloseInput, CloseOutput,    Read, ReadString, ReadInt, ReadCard, ReadWrd,    Write, WriteLn, WriteString, WriteInt, WriteCard,    WriteOct, WriteHex, WriteWrd;  CONST EOL = 36C;  VAR Done:  BOOLEAN;    termCH:  CHAR;  (*terminating character in ReadInt, ReadCard*)    in, out: File;  (*for exceptional cases only*)  PROCEDURE OpenInput(defext: ARRAY OF CHAR);    (*request a file name and open input file "in".      Done := "file was successfully opened".      If open, subsequent input is read from this file.      If name ends with ".", append extension defext*)  PROCEDURE OpenOutput(defext: ARRAY OF CHAR);    (*request a file name and open output file "out"      Done := "file was successfully opened.      If open, subsequent output is written on this file*)  PROCEDURE CloseInput;    (*closes input file; returns input to terminal*)  PROCEDURE CloseOutput;    (*closes output file; returns output to terminal*)  PROCEDURE Read(VAR ch: CHAR);    (*Done := NOT in.eof*)  PROCEDURE ReadString(VAR s: ARRAY OF CHAR);    (*read string, i.e. sequence of characters not containing      blanks nor control characters; leading blanks are ignored.      Input is terminated by any character <= " ";      this character is assigned to termCH.      DEL is used for backspacing when input from terminal*)p  PROCEDURE ReadInt(VAR x: INTEGER);    (*read string and convert to integer. Syntax:        integer = ["+"|"-"] digit {digit}.      Leading blanks are ignored.      Done := "integer was read"*)  PROCEDURE ReadCard(VAR x: CARDINAL);    (*read string and convert to cardinal. Syntax:        cardinal = digit {digit}.      Leading blanks are ignored.      Done := "cardinal was read"*)  PROCEDURE ReadWrd(VAR w: WORD);    (*Done := NOT in.eof*)  PROCEDURE Write(ch: CHAR);  PROCEDURE WriteLn;    (*terminate line*)  PROCEDURE WriteString(s: ARRAY OF CHAR);  PROCEDURE WriteInt(x: INTEGER; n: CARDINAL);    (*write integer x with (at least) n characters on file "out".      If n is greater than the number of digits needed,      blanks are added preceding the number*)  PROCEDURE WriteCard(x,n: CARDINAL);  PROCEDURE WriteOct(x,n: CARDINAL);  PROCEDURE WriteHex(x,n: CARDINAL);  PROCEDURE WriteWrd(w: WORD);END InOut.p B11.2.  RealInOut+Niklaus Wirth  15.5.82Library module for formatted input/output of real numbers on terminal or files.  It works together with the module InOut.  A description of this module is included to the Modula-2 manual [1].w151Imported Library Module0x25 nInOut+ w151Definition Module0= x25DEFINITION MODULE RealInOut;   (*N.Wirth  16.8.81*)  EXPORT QUALIFIED ReadReal, WriteReal, WriteRealOct, Done;  VAR Done: BOOLEAN;  PROCEDURE ReadReal(VAR x: REAL);  (*Read REAL number x from keyboard according to syntax:    ["+"|"-"] digit {digit} ["." digit {digit}] ["E"["+"|"-"] digit [digit]]    Done := "a number was read".    At most 7 digits are significant, leading zeros not    counting.  Maximum exponent is 38. Input terminates    with a blank or any control character.  DEL is used    for backspacing*)  PROCEDURE WriteReal(x: REAL; n: CARDINAL);  (*Write x using n characters. If fewer than n characters    are needed, leading blanks are inserted*)  PROCEDURE WriteRealOct(x: REAL);  (*Write x in octal form with exponent and mantissa*)END RealInOut.p B11.3.  Mouse+Niklaus Wirth  15.5.82Library module for handling the mouse and tracking a cursor on the screen.  A description of this module is included to the Modula-2 manual [1].  This module does not work together with the screen software package described in chapter 10, but it may be used with module LineDrawing.  All exported variables must be considered as 1read-only0 variables.w151Imported Library Module0x25 nBitmapVars+ w151Definition Module0= x25DEFINITION MODULE Mouse;  (*NW 2.1.82*)  EXPORT QUALIFIED keys, Mx, My, curOn,      TrackMouse, FlipCursor, ShowMenu;  VAR keys:   BITSET;    (*Mouse keys*)      Mx, My: INTEGER;   (*Mouse and cursor coordinates*)      curOn:  BOOLEAN;   (*cursor toggle switch; initial value = FALSE*)  PROCEDURE TrackMouse;    (*read Mouse coordinates Mx, My, and keys;      move cursor accordingly*)  PROCEDURE FlipCursor;    (*toggle switch for cursor*)  PROCEDURE ShowMenu(text: ARRAY OF CHAR; VAR selection: INTEGER);    (*show menu text at current cursor position, then follow the Mouse's      movements for command selection until menu key is released.      Selection = 0 means that no command was selected. In the text, command      lines are separated by "|". Command word have at most 7 characters,      and there must be at most 8 commands *)END Mouse.p B11.4.  LineDrawing+Niklaus Wirth  15.5.82Library module for drawing lines and writing strings on the screen.  A description of this module is included to the Modula-2 manual [1].  This module does not work together with the screen software package described in chapter 10.w151Imported Library Modules0x25 nFileSystemBitmapVarsByteBlockIO+ w151Definition Module0= x25DEFINITION MODULE LineDrawing;   (*NW 15.1.82*)  FROM FileSystem IMPORT File;  EXPORT QUALIFIED    width, height, PaintMode,    Px, Py, mode, CharWidth, CharHeight,    dot, line, area, copyArea, clear, Write, WriteString, WriteBitmap;  TYPE PaintMode = (replace, paint, invert, erase);  VAR Px, Py:     INTEGER;    (*current coordinates of pen*)      mode:       PaintMode;  (*current mode for paint and copy*)      width:      INTEGER;    (*width of picture area, read-only*)      height:     INTEGER;    (*height of picture area, read-only*)      CharWidth:  INTEGER;    (*width of a character, read-only*)      CharHeight: INTEGER;    (*height of a character, read-only*)  PROCEDURE dot(c: CARDINAL; x,y: INTEGER);    (*place dot at coordinate x,y*)  PROCEDURE line(d,n: CARDINAL);    (*draw a line of length n in direction d (angle = 45*d degrees) *)  PROCEDURE area(color: CARDINAL; x,y,w,h: INTEGER);    (*paint the rectangular area at x,y of width w and height h in color c      0 = white, 1 = light grey, 2 = dark grey, 3 = black*)  PROCEDURE copyArea(sx,sy,dx,dy,dw,dh: INTEGER);    (*copy rectangular area at sx,sy into rectangle at dx,dy of      width dw and height dh *)  PROCEDURE clear;  (*clear the screen*)  PROCEDURE Write(ch: CHAR);  (*write ch at pen's position*)  PROCEDURE WriteString(s: ARRAY OF CHAR);  PROCEDURE WriteBitmap(VAR f: File);END LineDrawing.p B11.5.  MathLib0+Niklaus Wirth  15.5.82Library module providing some basic mathematical functions.  A description of this module is included to the Modula-2 manual [1].w151Imported Library Module0x25 nTerminal+ w151Definition Module0= x25DEFINITION MODULE MathLib0;  (*standard functions;  J.Waldvogel/N.Wirth,  10.12.80*)  EXPORT QUALIFIED sqrt, exp, ln, sin, cos, arctan, real, entier;  PROCEDURE sqrt(x: REAL): REAL;  PROCEDURE exp(x: REAL): REAL;  PROCEDURE ln(x: REAL): REAL;  PROCEDURE sin(x: REAL): REAL;  PROCEDURE cos(x: REAL): REAL;  PROCEDURE arctan(x: REAL): REAL;  PROCEDURE real(x: INTEGER): REAL;  PROCEDURE entier(x: REAL): INTEGER;END MathLib0.p B11.6.  OutTerminal+Christian Jacobi  15.5.82This module contains a small collection of output conversion routines for numbers and strings.  The output is written to the terminal.Procedures:- f0 t90 120 .Write     writes a character WriteLn   writes an end of lineWriteT    writes a string (T=text) WriteI    writes an integerWriteC    writes a cardinalWriteO    writes octallength   0:   one leading blank        <>0:  no leading blank, the output is right adjusted in a field of "length" characters;              if the field is too small its size is augmented.              WriteT does left adjustment and has no leading blanks CDefinition Module-f7DEFINITION MODULE OutTerminal; (* Ch. Jacobi, S.E. Knudsen 18.8.80 *)  FROM SYSTEM IMPORT WORD;  EXPORT QUALIFIED    Write, WriteLn, WriteT,     WriteI, WriteC, WriteO;  PROCEDURE Write(ch: CHAR);  PROCEDURE WriteLn;  PROCEDURE WriteT(s: ARRAY OF CHAR; length: CARDINAL);  PROCEDURE WriteI(value: INTEGER; length: CARDINAL);  PROCEDURE WriteC(value: CARDINAL; length: CARDINAL);  PROCEDURE WriteO(value: WORD; length: CARDINAL);END OutTerminal.CImported Module-f0x25TerminalBp11.7.  OutFile+Christian Jacobi  15.5.82This module contains a small collection of output conversion routines for numbers and strings to a file. The procedures have different names than the corresponding procedures of the modules OutTerminal and OutWindow.  This simplifies combined imports ofthe module OutFile with one of the other formatting modules.Procedures for formatted output onto the files:- f0 t90 120 .WriteChar    writes a character WriteLine    writes an end of lineWriteText    writes a string  WriteInt     writes an integerWriteCard    writes a cardinalWriteOct     writes octallength   0:   one leading blank        <>0:  no leading blank, the output is right adjusted in a field of "length" characters;               if the field is too small its size is augmented.               WriteText does left adjustment and has no leading blanks CDefinition Module-f7DEFINITION MODULE OutFile; (* Ch. Jacobi, S.E. Knudsen 18.8.80 *)  FROM SYSTEM IMPORT WORD;  FROM FileSystem IMPORT File;  EXPORT QUALIFIED     WriteChar, WriteLine, WriteText,      WriteInt, WriteCard, WriteOct;  PROCEDURE WriteChar(VAR f: File; ch: CHAR);  PROCEDURE WriteLine(VAR f: File);  PROCEDURE WriteText(VAR f: File; s: ARRAY OF CHAR; length: CARDINAL);  PROCEDURE WriteInt(VAR f: File; value: INTEGER; length: CARDINAL);  PROCEDURE WriteCard(VAR f: File; value: CARDINAL; length: CARDINAL);  PROCEDURE WriteOct(VAR f: File; value: WORD; length: CARDINAL);END OutFile.CImported Module-f0x25FileSystemBp11.8.  OutWindow+Christian Jacobi  15.5.82This module contains a small collection of output conversion routines for numbers and strings into windows. Procedures for formatted output onto windows:- f0 t90 120 .Write     writes a character WriteLn   writes an end of lineWriteS    writes a string  WriteT    writes a string (T=text) with format WriteI    writes an integerWriteC    writes a cardinalWriteO    writes octallength   0:   one leading blank        <>0:  no leading blank, the output is right adjusted in a field of "length" characters;              if the field is too small its size is augmented.               WriteT does left adjustment and has no leading blanks CDefinition Module-f7DEFINITION MODULE OutWindow; (* Ch. Jacobi 11.1.81 *)  FROM SYSTEM IMPORT WORD;  FROM WindowHandler IMPORT Window;  EXPORT QUALIFIED    Write, WriteLn, WriteS, WriteT,     WriteI, WriteC, WriteO;  PROCEDURE Write(w: Window; ch: CHAR);  PROCEDURE WriteLn(w: Window);  PROCEDURE WriteS(w: Window; s: ARRAY OF CHAR);  PROCEDURE WriteT(w: Window; s: ARRAY OF CHAR; length: CARDINAL);  PROCEDURE WriteI(w: Window; value: INTEGER; length: CARDINAL);  PROCEDURE WriteC(w: Window; value: CARDINAL; length: CARDINAL);  PROCEDURE WriteO(w: Window; value: WORD; length: CARDINAL);END OutWindow.CImported Module-f0x25WindowHandlerp B11.9.  ByteIO+Svend Erik Knudsen  15.5.82w15 +Module 1ByteIO0 provides routines for reading and writing bytes on files.  This is valuable for the packing of information on files, if it is known that the ordinal values of the transferred elements are in the range 0..255.= w15DEFINITION MODULE ByteIO;     (* Medos-2 V4  S. E. Knudsen  1.6.81 *)  FROM FileSystem IMPORT File;  FROM SYSTEM IMPORT WORD;  EXPORT QUALIFIED ReadByte, WriteByte;  PROCEDURE ReadByte(VAR f: File; VAR w: WORD);  PROCEDURE WriteByte(VAR f: File; w: WORD);END ByteIO.+ w15 f1Explanations+ReadByte(f, w)+ x25 Y2Procedure 1ReadByte0 reads a byte from file f and assigns its value to w, i.e. 0 <= ORD(w) <= 255.+ w15WriteByte(f, w)+ x25 Y2Procedure 1WriteByte0 writes the low order byte of w (bits 8..15) on file f.+ w15 f1Example= x25MODULE ByteIODemo;      (* SEK  15.5.82 *)     FROM FileSystem IMPORT File, Lookup, Close;  FROM ByteIO IMPORT ReadByte, WriteByte;  VAR    inf, outf: File;    byte: CARDINAL;BEGIN  Lookup(inf, 'DK.Demo.from', FALSE);  Lookup(outf, 'DK.Demo.to', TRUE);  LOOP    ReadByte(inf,byte);    IF inf.eof THEN EXIT END;    WriteByte(outf, byte);  END;  Close(outf);  Close(inf)END ByteIODemo.+ w15 f1Imported Modules+ x25 nSYSTEMFileSystemp B11.10.  ByteBlockIO+Svend Erik Knudsen  15.5.82+ w15Module 1ByteBlockIO0 provides routines for efficient reading and writing of elements of any type on files.  Areas, given by their address and size in bytes, may be transferred efficiently as well.= w15DEFINITION MODULE ByteBlockIO;       (* Medos-2 V4  S. E. Knudsen  1.6.81 *)  FROM FileSystem IMPORT File;  FROM SYSTEM IMPORT WORD, ADDRESS;  EXPORT QUALIFIED    ReadByteBlock, WriteByteBlock,    ReadBytes, WriteBytes;  PROCEDURE ReadByteBlock(VAR f: File; VAR block: ARRAY OF WORD);  PROCEDURE WriteByteBlock(VAR f: File; VAR block: ARRAY OF WORD);  PROCEDURE ReadBytes(VAR f: File; addr: ADDRESS; count: CARDINAL;                      VAR actualcount: CARDINAL);  PROCEDURE WriteBytes(VAR f: File; addr: ADDRESS; count: CARDINAL);END ByteBlockIO.+ w15 f1Explanations+ReadByteBlock(f, block); WriteByteblock(f, block)x25 Y21ReadByteBlock0 and 1WriteByteBlock0 transfer the given block (ARRAY OF WORD) to or from file 1f0.  The bytes are transferred according to the description given for 1ReadBytes0 and 1WriteBytes0.+ w15ReadBytes(f, addr, count, actualcount); WriteBytes(f, addr, count)+ x25 Y21ReadBytes0 and 1WriteBytes0 transfer the given area (beginning at address 1addr0 and with 1count0 bytes (stored in (count+1) DIV 2 words)to or from the file f.  The number of the actually read bytes is assigned to 1actualcount0.  1ReadBytes0 and 1WriteBytes0 transfer two bytes toor from each word; first the high order byte (bits 0..7), afterwards the low order byte (bits 8..15).  If 1(actual-)count0 is odd, only the high order byteis transferred to or from the last word.+ w15 f1Example= x25MODULE ByteBlockIODemo;       (* SEK  15.5.82 *)     FROM FileSystem IMPORT File, Response, Lookup, Close;  FROM ByteBlockIO IMPORT ReadByteBlock;  VAR r: RECORD (*...*) END;      f: File;BEGIN  Lookup(f, 'DK.Demo', FALSE);  IF f.res = done THEN    LOOP      ReadByteBlock(f, r);      IF f.eof THEN EXIT END;      (* use r *)    END;    Close(f)  ELSE (* file not found *)  ENDEND ByteBlockIODemo.+ w15 f1Restriction+ x25The longest block which can be transferred by a single call to1ReadByteBlock0 or 1WriteByteBlock0 contains 2**15 - 1 words.+ w15 f1Imported Modules+ x25 nSYSTEMFileSystem+ w15 f1Algorithm+ x25The routines repeatedly determinates the longest segment of bytes, which can bemoved to or from the file buffer and move this segment by use of a CODE-procedures (MOV, LXB and SXB-instructions).p B11.11.  FileNames+Svend Erik Knudsen  15.5.82+ w15Module 1FileNames0 makes it easier to read in file names from the keyboard (i.e.  from module 1Terminal0) and to handle defaults for such file names.= w15DEFINITION MODULE FileNames;    (* Medos-2 V4  S. E. Knudsen  1.6.81 *)  EXPORT QUALIFIED    ReadFileName, Identifiers, IdentifierPosition;  PROCEDURE ReadFileName(VAR fn: ARRAY OF CHAR; dfn: ARRAY OF CHAR);  PROCEDURE Identifiers(fn: ARRAY OF CHAR): CARDINAL;  PROCEDURE IdentifierPosition(fn: ARRAY OF CHAR; identno: CARDINAL): CARDINAL;END FileNames.+ w15 f1Explanations+ReadFileName(fn, dfn)+ x25 Y2Procedure 1ReadFileName0 reads the file name 1fn0 according to the given default file name 1dfn0.  If no valid file name could be returned, fn[0] is set to 0C.  The character typed in in order to terminate the file name, must be read after the call to 1ReadFileName0.  One of the characters eol, " ", "/", CAN and ESC terminates the input of a file name.  If CAN or ESC has been typed, fn[0] is set 0C too.+ w15Identifiers(filename)+ x25 Y2Function 1Identifiers0 returns the number of identifiers in the given file name.+ w15IdentifierPosition(filename, identifierno)+ x25 Y2Function 1IdentifierPosition0 returns the index of the first character ofthe identifier 1identifierno0 in the given file name.  The first identifierin the file name is given number 0.  The length of a given file name 1fn0 is returnedby the following function call: 1IdentifierPosition(fn, Identifiers(fn))0.+ w15 f1Syntax of the Different Names+ t 200 210. x25FileName = MediumName [ "." LocalFileName ] [ 0C | " " ] .MediumName = Identifier .LocalFileName = [ QualIdentifier "." ] Extension .QualIdentifier = Identifier { "." Identifier } .Extension = Identifier .Identifier = WildcardLetter { WildcardLetter | Digit } .WildcardLetter = Letter | "*" | "%" .DefaultFileName = [ MediumName ] [ "." [ DefaultLocalName ] ] [ 0C | " " ] .DefaultLocalName = [ [ QualIdentifier ] "." ] Extension .InputFileName = [ "#" [ MediumName ] [ "." InputLocalName ] | InputLocalName ] .InputLocalName = [ QualInput "." ] Extension .QualInput = [ QualIdentifier [ "." ] ] [ "." QualIdentifier ] .+The scanning of the typed in 1InputFileName0 is terminated by the charactersESC and CAN or at a syntatically correct position by thecharacters 1eol0, " " and "/".  The termination character may beread after the call.  For correction of typing errors, DEL isaccepted at any place in the input.  Typed in characters not fitting into the syntax are simply ignored and not echoed on the screen.Wildcard characters ("*", "%") are only accepted, if the default file name contains wildcard characters.For routine 1ReadFileName0 a file name consists of a 1medium name0 part and of an optional 1local file name0 part.  The local file name part consists of an extension and optionally of a sequence of identifiers delimited by periods before the extension.When typing in an 1InputFileName0, an omitted part in the 1InputFileName0 is substituted by the corresponding part in the given default file name whenever the part is needed for building a syntactically correct 1FileName0.  If the corresponding part in the default file name is empty, the part must be typed.1Note:0 As all file names contain at least a medium name, don't forget the default medium name in a call to 1ReadFileName0. w15 f1Examples= x25 n t275.ReadFileName(fn, "DK") 0Default for medium name7ReadFileName(fn, "DK..MOD") 0Defaults for medium name and extension7ReadFileName(fn, "DK.Temp.MOD") 0Defaults for all three parts of a file name7ReadFileName(fn, "DK.*") 0Defaults for medium name and extension, wildcards accepted7+ w15 f1Error Message+ n f7 x25ReadFileName called with incorrect default+ w15 f1Imported Module+ x25 nTerminalp B11.12.  Options+Leo Geissmann  27.9.82Library module for reading a 1file name0 followed by 1program options0 from the keyboard.  File name and options are accepted according to the syntax given in 4.2.3. and 4.3.w151Imported Library Modules0x25 nTerminalFileNames+ w151Definition Module0= x25DEFINITION MODULE Options; (* AKG 28.05.80; LG 10.10.80 *)  EXPORT QUALIFIED Termination, FileNameAndOptions, GetOption;  TYPE Termination = (normal, empty, can, esc);  PROCEDURE FileNameAndOptions(default: ARRAY OF CHAR; VAR name: ARRAY OF CHAR;                               VAR term: Termination; acceptOption: BOOLEAN);  PROCEDURE GetOption(VAR optStr: ARRAY OF CHAR; VAR length: CARDINAL);END Options.+Procedure 1FileNameAndOptions0 first reads a file name by calling procedure 1ReadFileName0 of module 1FileNames0.  If 1acceptOption0 is TRUE, it afterwads reads program options from  the terminal.  The procedure reads all characters from terminal until one of the keys 2RETURN0, 2BLANK0 (space-bar), 2CTRL-X0, or 2ESC0 is typed.For the file name, a 1default0 file name may be proposed.  The accepted name is returned with parameter 1name0, and 1term0 indicates, how the input was terminated.  The meaning of the values of type 1Termination0 isx25 t120.2normal0  input normally terminated2empty0   input normally terminated, but name is empty2can0     CTRL-X was typed, input line is cancelled2esc0     ESC was typed, no file is specified.Y6Consider that 1name[0] = 0C0 when 1term <> normal0.+Procedure 1GetOption0 may be called repeatedly after FileNameAndOptions to get the accepted options.  It returns the next option string in 1optStr0 and its length in 1length0.  The string is terminated with a 20C0 character, if 1length <= HIGH(optStr)0.  Length gets the value 200, if no option is returned.+ w151Example0= x25LOOP  Terminal.WriteString("file > ");  Options.FileNameAndOptions(default, name, termstat, TRUE);  IF termstat = Options.esc THEN    Terminal.WriteString(" -- no file");    Terminal.WriteLn;    continue := FALSE;    EXIT;  ELSIF termstat = Options.can THEN    Terminal.WriteString(" -- cancelled");    Terminal.WriteLn;p  ELSE (* normal OR empty *)    IF termstat = Options.empty THEN      Terminal.WriteString(default);      name := default;    END;    Terminal.WriteLn;    FileSystem.Lookup(file, name, FALSE);    IF file.res = FileSystem.done THEN      Options.GetOption(opttext, optlength);      WHILE optlength > 0 DO        (* ... interprete program option ... *)        Options.GetOption(opttext, optlength);      END;      continue := TRUE;      EXIT;    ELSE      Terminal.WriteString(" ---- file not found");      Terminal.WriteLn;    END;  END;END; (* LOOP *)p B11.13.  Line+Svend Erik Knudsen  15.5.82+ w15Module 1Line0 is used for reading or writing characters over the RS-232 asynchronous line adapter.  Character 36C (=1eol0) is converted into CR LF if it is written to the line and vice versa.= w15DEFINITION MODULE Line;        (* Medos-2 V4  S. E. Knudsen  1.6.81 *)  EXPORT QUALIFIED Read, BusyRead, Write;  PROCEDURE Read(VAR ch: CHAR);  PROCEDURE BusyRead(VAR ch: CHAR);  PROCEDURE Write(ch: CHAR);END Line.+ w15 f1Explanations+Read(ch)+ x25 Y2Procedure 1Read0 gets the next character from the line and assigns it to 1ch0.  The character sequence CR LF (15C 12C) is converted to 1eol0.+ w15BusyRead(ch)+ x25 Y2Procedure 1BusyRead0 assigns 0C to 1ch0 if no character is received on the line.  Otherwise, the received character is assigned to 1ch0.+ w15Write(ch)+ x25 Y2Procedure 1Write0 writes the given character on the line.  Character 1eol0 is hereby converted to CR LF (15C 12C).+ w15 f1Restrictions+ x25Module 1Line0 must not be used together with module 1V240 (see chapter 11.14).The received characters might be lost, if procedure 1Read0 or 1BusyRead0 are not called frequently enough.  Buffering cannot easily be provided because the line adapter generates no interrupts.p B11.14.  V24+Svend Erik Knudsen  15.5.82+ w15Module 1V240 is used for reading or writing characters over the RS-232 asynchronous line adapter.  No character conversions are implied in the routines.= w15DEFINITION MODULE V24;       (* Medos-2 V4  S. E. Knudsen  1.6.81 *)  EXPORT QUALIFIED BusyRead, Read, Write;  PROCEDURE BusyRead(VAR ch: CHAR; VAR got: BOOLEAN);  PROCEDURE Read(VAR ch: CHAR);  PROCEDURE Write(ch: CHAR);END V24.+ w15 f1Explanations+Read(ch)+ x25 Y2Procedure 1Read0 gets the next character from the line and assigns it to 1ch0.+ w15BusyRead(ch, got)+ x25 Y2Procedure 1BusyRead0 assigns FALSE to 1got0 if no character is received on the line.  Otherwise, the received character is assigned to 1ch0.+ w15Write(ch)+ x25 Y2Procedure 1Write0 writes the given character on the line.+ w15 f1Restrictions+ x25Module 1V240 must not be used together with module 1Line0 (see chapter 11.13).The received characters might be lost, if procedure 1Read0 or 1BusyRead0 are not called frequently enough.  Buffering cannot easily be provided because the line adapter generates no interrupts.B p11.15.  String+Christian Jacobi  28.6.82Library module for character string manipulations.Cf1 w15Definition Module-f7DEFINITION MODULE String;   (* Ch. Jacobi 28.6.82 *)  EXPORT QUALIFIED     first, last,     Length, Occurs, Insert, InsertCh, Delete, Copy, Same;  CONST    first =      0B;    last  = 177777B;  PROCEDURE Length(VAR string: ARRAY OF CHAR): CARDINAL;  PROCEDURE Occurs(VAR s: ARRAY OF CHAR; start: CARDINAL;                    w: ARRAY OF CHAR): CARDINAL;  PROCEDURE Insert(VAR s: ARRAY OF CHAR; at: CARDINAL; w: ARRAY OF CHAR);   PROCEDURE InsertCh(VAR s: ARRAY OF CHAR; at: CARDINAL; ch: CHAR);  PROCEDURE Delete(VAR s: ARRAY OF CHAR; start, length: CARDINAL);  PROCEDURE Copy(VAR s: ARRAY OF CHAR;                  source: ARRAY OF CHAR; start, length: CARDINAL);  PROCEDURE Same(VAR s: ARRAY OF CHAR; start, length: CARDINAL;                  w: ARRAY OF CHAR): BOOLEAN;END String.Cf1 w15Explanations+Character strings are represented the same way as the compiler generates string constants:+cY2StringType = 7ARRAY [0..maxlength-1] OF CHAR;0+Y2Either all elements (characters) are usedor the string is terminated by a (single) 0C character;The first (leftmost) character has position 0;the last (rightmost) character has position length-1.  +Length(string)+x25 Y2Function 1Length0 returns the number of characters in 1string0 (without counting aterminating 0C). 3The string is a VAR parameter for speedup reasons and is not modified.  The length of constant strings are known, anyway.0+Occurs(string, start, substring)+x25 Y2Function 1Occurs0 checks if 1substring0 occurs as asubstring of 1string0 starting at the character at position 1start0 or more to the right;The function returns the index of the first character, or 177777B if it does not occur.3The string is a VAR parameter for speedup reasons and is not modified.0+Insert(string, at, substring)+x25 Y2Procedure 1Insert0 inserts 1substring0 into 1string0 left of the characterat position 1at0. If the resulting 1string0 is to long to be stored in its memory available, it is clipped;If 1at0 > length(1string0) blanks are inserted in 1string0.If 1at0 = last 1substring0 is appended to 1string0.+InsertCh(string, at, ch)+x25 Y2Procedure 1InsertCh0 inserts 1ch0 into 1string0 left of the characterat position 1at0.If the resulting 1string0 is to long to be stored in its memory available, it is clipped;If 1at0 > length(1string0) blanks are inserted.If 1at0 = last  1ch0 is appended to 1string0.0C is considered as being no character.+Delete(string, start, length)+x25 Y2Procedure 1Delete0 removes the substring in 1string0 starting at position 1start0 with length 1length0.If 1start0 points to the right of the end, nothing happens.+Copy(string, source, start, length)+x25 Y2Procedure 1Copy0 copies a substring from 1source0 to 1string0; the substring starts with the character at the position 1start0 (inclusive) and is 1length0 characters long. If 1start0 and 1length0 denote non-existent characters(characters to the right of the last character) thenthe non-existent characters are ignored.  If the resulting string does not fit into the memory for 1string0, then it is clipped. +Same(string, start, length, substring)+x25 Y2Function 1Same0 denotes if the substring of 1string0 is equal to 1substring0; the substring starts at position 1start0 (inclusive) and is 1length0 characters long.If 1start0 and 1length0 denote non-existent characters(characters to the right of the last character) thenthe non-existent characters are not part of thesubstring used to compare.  All characters inside the string and the used substringare compared (including blanks).Cf1 w15Imported Modules-f0x25none