* MODULE DISPLAYHANDLER;* EXPORT BBLT,REPL,DCH,DDT;** (* PARAMETERS FOR THE BITHANDLING MACROINSTRUCTIONS ON THE EXPRESSION STACK:**   BBLT:          I          I*   =====          +----------+*                  I  SRCBMD  I  ^       REPL:     I          I*                  +----------+  I       =====     +----------+  ^*                  I DESTBLD  I  I                 I DESTBLD  I  I*                  +----------+  I                 +----------+  I*                  I  SRCBLD  I  I                 I  SOURCE  I  I*                  +----------+  I                 +----------+  I*                  I DESTBMD  I  I                 I   BMD    I  I*                  +----------+                    +----------+*                  I   MODE   I                    I   MODE   I*                  +----------+                    +----------+***        DCH:      I          I          DDT:      I          I*        ====      +----------+          ====      +----------+*                  I    CH    I  ^                 I     Y    I*                  +----------+  I                 +----------+*                  I DESTBLD  I  I                 I     X    I*                  +----------+  I                 +----------+*                  I FONTADDR I  I                 I    BMD   I*                  +----------+  I                 +----------+*                  I   BMD    I                    I   MODE   I*                  +----------+                    +----------+       *)**** TYPE*   BMDESCR = RECORD*     ADDR,*     WIDTH,HEIGHT : CARDINAL;*     WORD4 : PACKED RECORD*       INVERT     : BOOLEAN; *       WPRIM      : [0..63]; *       HPRIM      : [0..511];*     END;*   END;**   BLOCKDESCR = RECORD*     X,Y,*     WIDTH,HEIGHT : CARDINAL;*   END;**   PATTERN = RECORD*     COUNT        : CARDINAL;*     DOTS         : ARRAY [1..COUNT] OF BITSET;*   END;**   FONT = RECORD*     HEIGHT       : CARDINAL;*     CHAR         : ARRAY [0..255] OF POINTER TO CHARACTER; (* SELF RELATIV *) *     PSEUDOCHAR   : ARRAY [256..MAXCHAR] OF POINTER TO CHARACTER;*   END;**   CHARACTER = RECORD*     DOTS         : ARRAY [1..HEIGHT] OF BITSET; *     CASE EXTENDED OF*       FALSE : WIDTH     : CARDINAL;*       TRUE  : PSEUDOCHR : INTEGER; (* -INDEX TO THE ARRAY PSEUDOCHAR *)*     END;*     SKIP,HEIGHT  : 0..255;*   END;** VAR*   SRCBMD,DESTBMD, *   BMD             : BMDESCR;*   DESTBLD, SRCBLD : BLOCKDESCR;*   SOURCE          : PATTERN;*   FONTADDR        : POINTER TO FONT;***$*         PROCEDURE DDT;  (* NW 7.80*         ==============             *) *DDT       1 B   OR  DZ 0  -  0  -  - - -   S 0 POP -    STK -> R0          !X"          1 B   OR  DZ 0  -  1  -  - - -   S 0 MAR ALU  STK -> R1 -> MAR !BMD"          1 B   OR  DZ 0  -  3  -  - - -   - 0 ALU MD   MD -> R3          1 B   &   DA 0  3  4  -  - - -   - 1 3        3 & R3 -> R4    !BANK"          1 B   -&  DA 0  3  3  -  - - -   - 1 3        _3 & R3 -> R3    !BMA"          1 B   +   ZA 1  1  1  -  - - -   - 0 MAR ALU  R1+1 -> R1 -> MAR          1 Q   OR  DZ 0  -  -  -  - - -   - 0 ALU MD   MD -> Q            !W"          1 B   OR  ZQ 0  -  2  -  - - -   - 0 -   -    Q -> R2          1 B*  OR  DZ 0  2  2  R 14 - -   - 0 ALU ALU  (R2^14) -> R2           1 -   -   AB 1  0  2  -  - - -   - 0 -   -    R0 - R2          0 TRAP(4)    C             - JMP              TRAP(4) IF 16*W<=R0          1 -   +   ZA 1  1  -  -  - - -   - 0 MAR ALU  R1 + 1 -> MAR           1 B   +   DZ 1  -  1  -  - - -   - 0 ALU MD   MD+1 -> R1       !H+1"          1 B   -   AB 1  1  T  -  - - -   - 0 -   -    R1 - T -> T    !H+1-Y"          1 -   +   ZA 1  T  -  -  - - -   - 0 -   -    T + 1          0 TRAP(4)    FZ            - JMP              TRAP(4) IF H<=Y          0 #MUL16     T             - JSR              Q * T -> [R2,Q] !..*W"          1 B   +   AQ 0  3  3  -  - - -   - 0 -   -    Q + R3 -> R3  !..+BMA"          1 B*  OR  DZ 0  0  1  R  4 - -   - 0 ALU ALU  R0^4 -> R1  !X DIV 16"          1 B   -&  DA 0  1  1  M  4 - -   - 1 0        _MSK(0,4) & R1 -> R1          1 -   OR  ZA 0  4  -  -  - - -   - 0 BNK ALU  R4 -> BNK          1 B   +   AB 0  1  3  -  - - -   - 0 MAR ALU  R1+R3 -> R3 -> MAR.                                                      !(H+1-Y)*W + BMA + X/16"           1 -   +   ZA 1  0  -  -  - - -   - 0 SR  ALU  R0+1->SCR !(X+1)MOD16"          1 B   OR  DZ 0  -  2  -  - - -   - 0 ALU MD   MD -> R2          1 B   OR  DZ 0  -  1  RR - - -   - 1 1        1^SR -> R1          1 B   OR  DZ 0  -  0  -  - - -   S 0 POP -    STK -> R0          !M"          1 -   -+  DA 1  0  -  -  - - -   - 1 2        R0 - 2          0 #INV       Z             - JMP              IF R0=2          0 #SET       S             - JMP              IF R0<2#CLR      1 -   -&  AB 0  1  2  -  - - -   - 0 MD  ALU  _R1 & R2 -> MD          0 #DD        T             - JMP#INV      1 -   XOR AB 0  1  2  -  - - -   - 0 MD  ALU  R1 XOR R2 -> MD          0 #DD        T             - JMP#SET      1 -   OR  AB 0  1  2  -  - - -   - 0 MD  ALU  R1 OR R2 -> MD#DD       1 -   OR  ZA 0  4  -  -  - - -   - 0 BNK ALU  R4 -> BNK          1 B*  OR  DZ 0  3  T  -  - - -   S 0 MAR ALU  R3 -> MAR, STK -> T          1 Q   OR  DZ 0  -  -  -  - S JMP - 0 ALU IR4  JMAP$*         PROCEDURE DCH;  (* WW 27.3.79 *         ==============                                *)*           POP(CH);                                    T : CH*           POP(DESTBLD);                               L : DESTBLD*           POP(FONTADDR);                              3 : FONTADDR*           POP(BMD);                                   4 : BMD*           DX := DESTBLD.X;                            8 : DX*           PUSH(M);*           DY := DESTBLD.Y;                            M : DYDCH       1 Q   OR  DZ 0  -  -  -  - - -   S 0 MAR ALU  STK -> Q -> MAR          1 B   OR  DZ 0  -  3  -  - - -   S 0 POP -    STK -> R3          1 B   OR  DZ 0  -  4  -  - - -   S 0 POP -    STK -> R4          1 B   OR  DZ 0  -  10 -  - - -   - 0 ALU MD   MD -> R10          1 -   +   ZQ 1  -  -  -  - - -   - 0 MAR ALU  Q+1 -> MAR          1 B*  OR  DZ 0  M  11 -  - - -   S 0 ALU MD   M -> STK, MD -> R11*           BMA := BMD.ADDR;                            5 : BMA*           PUSH(H);*           BMWIDTH := BMD.WIDTH;                       6 : BMWIDTH*           PUSH(S);*           BMHEIGHT := BMD.HEIGHT + 1                  0 : BMHEIGHT          1 -   OR  ZA 0  4  -  -  - - -   - 0 MAR ALU  R4 -> MAR          1 B*  OR  DZ 0  P  5  -  - - -   S 0 ALU MD   P -> STK, MD -> R5          1 B   +   ZA 1  4  4  -  - - -   - 0 MAR ALU  R4+1 -> R4 -> MAR          1 B*  OR  DZ 0  H  6  -  - - -   S 0 ALU MD   H -> STK, MD -> R6          1 -   +   ZA 1  4  -  -  - - -   - 0 MAR ALU  R4+1 -> MAR          1 B*  +   DZ 1  S  0  -  - - -   S 0 ALU MD   S -> STK, MD+1 -> R0*           BLOCKWIDTH := 0;                            S : BLOCKWIDTH*           PUSH(G);*           PUSH(L);*           DWORD := BMHEIGHT - DY;                     M : DWORD*           CH := CH MOD 377;                           M : CH*           DWORD := BMWIDTH * DWORD;                   Q : DWORD          1 B*  &   ZA 0  G  S  -  - - -   S 0 PSH -    G -> STK, 0 -> S          1 B*  OR  ZQ 0  L  L  -  - - -   S 0 PSH -    L -> STK, Q -> L          1 B   -   AB 1  0  11 -  - - -   - 0 -   -    R0 - R11 -> R11          1 -   +   ZA 1  11 -  -  - - -   S 0 PSH -    R11 + 1 -> STK          1 Q   OR  ZA 0  11 -  -  - - -   - 0 -   -    R11 -> Q          1 B   &   DA 0  T  11 -  - - -   - 1 377      T & 377 -> R11          1 B   OR  ZA 0  6  T  -  - - -   - 0 -   -    R6 -> T          0 #MUL16     T             - JSR              Q * T -> Q  (-2-)*           DWORD := DWORD + BMA + (DX DIV 16);         1 : DWORD*           BITADDR := DX MOD 16;                       0 : BITADDR*           FBANK := FONTADDR MOD 4;                    H : FBANK*           BANK := BMA MOD 4;                          2 : BANK          1 B*  OR  DZ 0  10 1  R  4 - -   - 0 ALU ALU  R10^4 -> R1          1 B   -&  DA 0  1  1  M  4 - -   - 1 0         -MSK(0,4) & R1 -> R1          1 B   +   AQ 0  1  1  -  - - -   - 0 -   -    R1 + Q -> R1          1 B   &   DA 0  5  2  -  - - -   - 1 3        3 & R5 -> R2          1 B   -&  DA 0  5  5  -  - - -   - 1 3        _3 & R5 -> R5          1 B*  OR  DZ 0  3  3  R 16 - -   - 0 ALU ALU  (R3^16) -> R3          1 B   &   DA 0  3  H  -  - - -   - 1 3        3 & R3 -> H          1 B   -&  DA 0  3  3  -  - - -   - 1 3        _3 & R3 -> R3          1 B   +   AB 0  5  1  -  - - -   - 0 -   -    R1 + R5 -> R1          1 B   &   DA 0  10 0  -  - - -   - 1 17       R10 & 17 -> R0          1 B   OR  ZA 0  10 T  -  - - -   - 0 -   -    R10 -> T*           CONVERT(CH);*           POP(L);*           POP(G);*           DESTBLD.X := DESTBLD.X + BLOCKWIDTH;*           DESTBLD.W := DESTBLD.W + BLOCKWIDTH;*           POP(S);*           POP(F);*           POP(H);*           POP(P);*           POP(M);*           POP(T);*         END DCH;          0 #CONVERT         T       - JSR              CONVERT(R11)          1 B   OR  ZA 0  L  2  -  - - -   - 0 MAR ALU  L -> MAR -> R2          1 B   +   DA 0  S  0  -  - - -   - 0 ALU MD   MD + S -> R0          1 -   OR  ZA 0  0  -  -  - - -   - 0 MD  ALU  R0 -> MD          1 B*  +   ZA 1  2  2  -  - - -   - 0 MAR ALU  R2 -> MAR, R2 + 1 -> R2          1 -   +   ZA 1  2  -  -  - - -   - 0 MAR ALU  R2 + 1 => MAR          1 B   -   DA 1  S  0  -  - - -   - 0 ALU MD   MD - S -> R0          1 -   OR  ZA 0  0  -  -  - - -   - 0 MD  ALU  R0 -> MD          1 -   +   ZA 1  2  -  -  - - -   - 0 MAR ALU  R2 + 1 -> MAR          0 EXITDCH    T             - JSR              RESTORE REGS          1 Q   OR  DZ 0  -  -  -  - S JMP - 0 ALU IR4  JMAPTRAPDCH   0 0          T             - POP              FIX 2911 STACK          0 EXITDCH    T             - JSR              RESTORE REGS          0 TRAP(4)    T             - JMP              TRAP(4)EXITDCH   1 B   OR  DZ 0  -  0  -  - - -   S 0 POP -    STK -> DUMMY          1 B   OR  DZ 0  -  L  -  - - -   S 0 POP -    STK -> L          1 B   OR  DZ 0  -  G  -  - - -   S 0 POP -    STK -> G          1 B   OR  DZ 0  -  S  -  - - -   S 0 POP -    STK -> S          1 B   OR  DZ 0  -  H  -  - - -   S 0 POP -    STK -> H          1 B   OR  DZ 0  -  P  -  - - -   S 0 POP -    STK -> P          1 B   OR  DZ 0  -  M  -  - - -   S 0 POP -    STK -> M          1 B   OR  DZ 0  -  T  -  - - RTN S 0 POP -    STK -> T$*         PROCEDURE CONVERT (CH:CHARACTER);*         -----------------*           CHAR := FONTADDR + CH;                      9 : CHAR*           CHARPTR := CHAR + M[CHAR];                  9 : CHARPTR*           PSEUDOCHAR := 0;                            G : PSEUDOCHAR*           WIDTH := CHARPTR^.WIDTH;                    7 : WIDTH#CONVERT  1 -   OR  ZA 0  H  -  -  - - -   - 0 BNK ALU  H -> BNK          1 B   +   AB 0  3  11 -  - - -   - 0 MAR ALU  R3 + R11 -> R11 -> MAR          1 B   +   DA 0  11 11 -  - - -   - 0 ALU MD   MD + R11 -> R11          1 -   OR  ZA 0  H  -  -  - - -   - 0 BNK ALU  H -> BNK          1 B*  &   ZA 0  11 15 -  - - -   - 0 MAR ALU  R11 -> MAR, 0 -> G          1 B   OR  DZ 0  -  7  -  - - -   - 0 ALU MD   MD -> R7*           IF WIDTH < 0 THEN         (* CHARACTER WIDER THAN 16 BITS *)*             PSEUDOCHAR := COMPL(WIDTH);*             WIDTH := 16;*           END;          0 #CNV1        -F          - JMP              GOTO #CNV1 IF >=0          1 B   -   ZA 0  7  G  -  - - -   - 0 -   -    _R7 -> G          1 B   OR  DZ 0  -  7  -  - - -   - 1 20       16 -> R7*           BLOCKWIDTH := BLOCKWIDTH + WIDTH;           S : BLOCKWIDTH*           HEIGHT := CHARPTR^.HEIGHT;                  Q : HEIGHT*           NEXTBITADDR := BITADDR + WIDTH;             7 : NEXTBITADDR#CNV1     1 B   +   AB 0  7  T  -  - - -   - 0 -   -    R7 + T -> T          0 TRAPDCH    C             - JMP              TRAP IF OVERFLOW          1 B*  OR  DZ 0  6  5  R 14 - -   - 0 ALU ALU  (R6^14) -> R5           1 -   -   AB 1  5  T  -  - - -   - 0 -   -    R5 - T          0 TRAPDCH    -C            - JMP              TRAP IF 16*BMW < T          1 B   +   AB 0  7  S  -  - - -   - 0 -   -    R7 + S -> S          1 -   OR  ZA 0  H  -  -  - - -   - 0 BNK ALU  H -> BNK          1 -   +   ZA 1  11 -  -  - - -   - 0 MAR ALU  R11+1 -> MAR          1 B*  +   AB 0  0  7  -  - - -   - 0 SR  ALU  R0 -> SR, R0+R7 -> R7          1 B   OR  DZ 0  -  10 -  - - -   - 0 ALU MD   MD -> R10          1 Q   &   DA 0  10 -  -  - - -   - 1 377      R10 & 377 -> Q*           IF HEIGHT = 0*           THEN*             IF NEXTBITADDR >= 16 THEN *               NEXTBITADDR := NEXTBITADDR - 16;*               INC(DWORD);*             END;          0 #CNV10        -Z         - JMP              GOTO #CNV10 IF #0          1 -   -+  DA 1  7  -  -  - - -   - 1 20       R7 - 16          0 #CNV6         S          - JMP              GOTO CNV6 IF <0          0 #CNV50        T          - JMP              GOTO CNV50*           ELSE*             CURRENTWORDADDR := DWORD;                 4 : CURRENTWORDADDR*             SKIP := CHARPTR^.SKIP;                    8 : SKIP#CNV10    1 B   OR  ZA 0  1  4  -  - - -   - 0 -   -    R1 -> R4          1 B*  OR  DZ 0  10 10 R 10 - -   - 0 ALU ALU  R10^10 -> R10 *             WHILE SKIP > 0 DO*               CURRENTWORDADDR := CURRENTWORDADDR-*                                  BMWIDTH;*               DEC(SKIP);*             END;          1 B   &   DA 0  10 10 -  - - -   - 1 377      R10 & 377 -> R10                    1 B   OR  DZ 0  -  5  -  - - -   S 0 POP -    STK -> R5          1 -   OR  ZA 0  5  -  -  - - -   S 0 PSH -    R5 -> STK          1 B   -+  AB 1  10 5  -  - - -   - 0 -   -    R5 - R10 -> R5          0 TRAPDCH    -C            - JMP              TRAP IF R5<R10          1 -   -   AQ 1  5  -  -  - - -   - 0 -   -    R5 - Q          0 TRAPDCH    -C            - JMP              TRAP IF R5<Q          1 -   OR  ZA 0  10 -  -  - - -   - 0 -   -    R10           0 #CNV3         Z          - JMP              GOTO #CNV3 IF =0#CNV2     1 B   -+  AB 1  6  4  -  - - -   - 0 -   -    R4 - R6 -> R4           1 B   -+  ZA 0  10 10 -  - - -   - 0 -   -    R10-1 -> R10          0 #CNV2        -Z          - JMP              GOTO #CNV2 IF #0*                                                       8 : HEIGHT*             CURRENTWORDADDR := CURRENTWORDADDR+ *                                BMWIDTH;*             IF NEXTBITADDR < 16*             THEN        (* NO WRAP AROUND *)#CNV3     1 B   OR  ZQ 0  -  10 -  - - -   - 0 -   -    Q -> R10          1 B   +   AB 0  6  4  -  - - -   - 0 -   -    R4 + R6 -> R4           1 -   -+  DA 1  7  -  -  - - -   - 1 20       R7 - 16          0 #CNV5        -S          - JMP              GOTO #CNV5 IF >=0*               FOR I := HEIGHT DOWN TO 1 DO            8 : I*                 R5 := ROT(CHARPTR^.DOTS[I],BITADDR);  5 : R5*                 CURRENTWORDADDR := CURRENTWORDADDR-*                                    BMWIDTH;*                 M[CURRENTWORDADDR] := M[C.W.A] OR R5;*               END;#CNV4     1 -   OR  ZA 0  H  -  -  - - -   - 0 BNK ALU  H -> BNK          1 B   -+  ZA 0  11 11 -  - - -   - 0 MAR ALU  R11-1 -> R11 -> MAR          1 B   OR  DZ 0  -  5  RR - - -   - 0 ALU MD   MD^SR -> R5          1 -   OR  ZA 0  2  -  -  - - -   - 0 BNK ALU  R2 -> BNK          1 B   -+  AB 1  6  4  -  - - -   - 0 MAR ALU  R4 - R6 -> R4 -> MAR          1 B   OR  DA 0  5  5  -  - - -   - 0 ALU MD   MD OR R5 -> R5          1 -   OR  ZA 0  5  -  -  - - -   - 0 MD  ALU  R5 -> MD          1 -   OR  ZA 0  2  -  -  - - -   - 0 BNK ALU  R2 -> BNK          1 -   OR  ZA 0  4  -  -  - - -   - 0 MAR ALU  R4 -> MAR          1 B   -+  ZA 0  10 10 -  - - -   - 0 -   -    R10-1 -> R10          0 #CNV4        -Z          - JMP              GOTO #CNV4 IF #0          0 #CNV6         T          - JMP              GOTO #CNV6*             ELSE        (* WRAP AROUND *)*               FOR I := HEIGHT DOWNTO 1 DO#CNV5     1 -   OR  ZA 0  H  -  -  - - -   - 0 BNK ALU  H -> BNK          1 B   -+  ZA 0  11 11 -  - - -   - 0 MAR ALU  R11-1 -> R11 -> MAR          1 B   OR  DZ 0  -  5  RR - - -   - 0 ALU MD   MD^SR -> R5          1 B   -XR DZ 0  -  12 MR - - -   - 1 0        -MSK(0,SR) -> R12          1 B   &   AB 0  5  12 -  - - -   - 0 -   -    R5 & R12 -> R12          1 -   OR  ZA 0  2  -  -  - - -   - 0 BNK ALU  R2 -> BNK          1 B   -+  AB 1  6  4  -  - - -   - 0 MAR ALU  R4 - R6 -> R4 -> MAR          1 B   OR  DA 0  12 12 -  - - -   - 0 ALU MD   MD OR R12 -> R12          1 -   OR  ZA 0  12 -  -  - - -   - 0 MD  ALU  R12 -> MD          1 -   OR  ZA 0  2  -  -  - - -   - 0 BNK ALU  R2 -> BNK          1 -   OR  ZA 0  4  -  -  - - -   - 0 MAR ALU  R4 -> MAR*                 R5 := ROT(CHARPTR^.DOTS[I],BITADDR);  5 : R5*                 C.W.A. := C.W.A. - BMWIDTH;*                 M[C.W.A.] := M[C.W.A.] OR (R5 MOD 2**BITADDR);*               END;          1 B   &   DA 0  5  5  MR - - -   - 1 0        MSK(0,SR) & R5 -> R5          1 -   OR  ZA 0  2  -  -  - - -   - 0 BNK ALU  R2 -> BNK          1 -   +   ZA 1  4  -  -  - - -   - 0 MAR ALU  R4 + 1 -> MAR           1 B   OR  DA 0  5  5  -  - - -   - 0 ALU MD   MD OR R5 -> R5          1 -   OR  ZA 0  5  -  -  - - -   - 0 MD  ALU  R5 -> MD          1 -   OR  ZA 0  2  -  -  - - -   - 0 BNK ALU  R2 -> BNK          1 -   +   ZA 1  4  -  -  - - -   - 0 MAR ALU  R4 + 1 -> MAR           1 B   -+  ZA 0  10 10 -  - - -   - 0 -   -    R10 - 1 -> R10          0 #CNV5        -Z          - JMP              GOTO #CNV5 IF #0*               NEXTBITADDR := N.B.A. - 16;*               INC(DWORD);*             END;#CNV50    1 B   -+  DA 1  7  7  -  - - -   - 1 20       R7 - 16 -> R7           1 B   +   ZA 1  1  1  -  - - -   - 0 -   -    R1 + 1 -> R1*             BITADDR := NEXTBITADDR;                   0 : BITADDR*           END;*           CH := PSEUDOCHAR; *           IF CH # 0 THEN CONVERT(CH); END;*         END CONVERT;#CNV6     1 B   OR  ZA 0  7  0  -  - - -   - 0 -   -    R7 -> R0          1 B   OR  ZA 0  G  11 -  - - -   - 0 -   -    G -> R11          0 #CONVERT     -Z          - JMP              JMP CONVERT IF #0          0 0             T          - RTN              RETURN***$*         PROCEDURE INIT;  (* WW 29.2.79*         --------------                 *)*           POP(DESTBLD);                               T : DESTBLD*           POP(SRCBLD);                                P : SRCBLD*          [REPL: POP(SOURCE);                          P : SOURCE]*           POP(BMD);                                   Q : BMD*           POP(MODE);                                  0 : MODE*           PUSH(M);#INIT     1 B   OR  DZ 0  -  3  -  - - -   S 0 POP -    STK -> R3          1 Q   OR  DZ 0  -  -  -  - - -   S 0 POP -    STK -> Q          1 B   OR  DZ 0  -  0  -  - - -   S 0 POP -    STK -> R0          1 -   OR  ZA 0  M  -  -  - - -   S 0 PSH -    M -> STK*           PUSH(L);*           DX := DESTBLD.X;                            6 : DX*           PUSH(G);*           DY := DESTBLD.Y;                            8 : DY*           PUSH(H);*           DW := DESTBLD.WIDTH;                        H : DW*           PUSH(P);*           DH := DESTBLD.HEIGHT;                       M : DH*                                                       T : BMD          1 B*  +   ZA 1  T  T  -  - - -   - 0 MAR ALU  T -> MAR, T+1 -> T          1 B*  OR  DZ 0  L  6  -  - - -   S 0 ALU MD   L -> STK, MD -> R6          1 B*  +   ZA 1  T  T  -  - - -   - 0 MAR ALU  T -> MAR, T+1 -> T          1 B*  OR  DZ 0  G  10 -  - - -   S 0 ALU MD   G -> STK, MD -> R10          1 B*  +   ZA 1  T  T  -  - - -   - 0 MAR ALU  T -> MAR, T+1 -> T          1 B*  OR  DZ 0  H  H  -  - - -   S 0 ALU MD   H -> STK, MD -> H          1 B*  OR  ZQ 0  T  T  -  - - -   - 0 MAR ALU  T -> MAR, Q -> T          1 B*  OR  DZ 0  P  11 -  - - -   S 0 ALU MD   P -> STK, MD -> R11*           PUSH(S);*           BMA := BMD.ADDR;                            S : BMA*           BMWIDTH := BMD.WIDTH;                       4 : BMWIDTH*           BMHEIGHT := BMD.HEIGHT + 2                  2 : BMHEIGHT*           IF (DX+DW >= 2**16)*           OR (DX+DW > 16*BMWIDTH)*           OR (DY+DH >= 2**16)*           OR (DY+DH > BMHEIGHT)*           THEN TRAP END;*           SX := SRCBLD.X                              5 : SX*          [REPL: LENGTH := SOURCE.COUNT;               5 : LENGTH]*         END INIT;                                     Q : 'FFF'          1 B*  +   ZA 1  T  T  -  - - -   - 0 MAR ALU  T -> MAR, T+1 -> T          1 B*  OR  DZ 0  S  S  -  - - -   S 0 ALU MD   S -> STK, MD -> S          1 B*  +   ZA 1  T  T  -  - - -   - 0 MAR ALU  T -> MAR, T+1 -> T          1 B   OR  DZ 0  -  4  -  - - -   - 0 ALU MD   MD -> R4          1 -   OR  ZA 0  T  -  -  - - -   - 0 MAR ALU  T -> MAR          1 B   OR  DZ 0  -  2  -  - - -   - 0 ALU MD   MD -> R2          1 B   +   DA 0  2  2  -  - - -   - 1 2        2 + R2 -> R2          1 B   OR  ZA 0  6  5  -  - - -   - 0 -   -    R6 -> R5          1 B   +   AB 0  H  5  -  - - -   - 0 -   -    H + R5 -> R5          0 TRAPBB     C             - JMP              TRAP IF OVERFLOW          1 B*  OR  DZ 0  4  P  R 14 - -   - 0 ALU ALU  (R4^14) -> P            1 -   -   AB 1  P  5  -  - - -   - 0 -   -    P - R5          0 TRAPBB     -C            - JMP              TRAP IF P<R5            1 B   OR  ZA 0  10 5  -  - - -   - 0 -   -    R10 -> R5          1 B   +   AB 0  M  5  -  - - -   - 0 -   -    M + R5 -> R5          0 TRAPBB     C             - JMP              TRAP IF OVERFLOW          1 -   -   AB 1  2  5  -  - - -   - 0 -   -    R2 - R5          0 TRAPBB     -C            - JMP              TRAP IF R2<R5           1 B*  +   ZA 1  3  12 -  - - -   - 0 MAR ALU  R3 -> MAR, R3+1 -> R12          1 B   OR  DZ 0  -  5  -  - - -   - 0 ALU MD   MD -> R5          1 Q   -XR DZ 0  -  -  M  4 - RTN - 1 0        _MSK(0,4) -> Q, RTNTRAPBB    0 0          T             - POP              FIX 2911 STACK          0 EXITREPL   T             - JSR              RESTORE REGS          0 TRAP(4)    T             - JMP              TRAP(4)EXITBBLT  1 -   OR  DZ 0  -  -  -  - - -   S 0 POP -    STK -> DUMMY          1 -   OR  DZ 0  -  -  -  - - -   S 0 POP -    STK -> DUMMYEXITREPL  1 B   OR  DZ 0  -  S  -  - - -   S 0 POP -    STK -> S          1 B   OR  DZ 0  -  P  -  - - -   S 0 POP -    STK -> P          1 B   OR  DZ 0  -  H  -  - - -   S 0 POP -    STK -> H          1 B   OR  DZ 0  -  G  -  - - -   S 0 POP -    STK -> G          1 B   OR  DZ 0  -  L  -  - - -   S 0 POP -    STK -> L          1 B   OR  DZ 0  -  M  -  - - -   S 0 POP -    STK -> M          1 B   OR  DZ 0  -  T  -  - - RTN S 0 POP -    STK -> T          1 Q   OR  DZ 0  -  -  -  - S JMP - 0 ALU IR4  JMAP$*         PROCEDURE BBLT;  (* BLOCK TO BLOCK TRANSFER*         ===============                             *)*           POP(SBMD);                                  1 : SBMD*           INIT;*           DBMW := DBMWIDTH;                           3 : DBMW*           SY := SRCBLD.Y;                             7 : SY*           SBMW := SBMD.W;                             P : SBMWBBLT      1 B   OR  ZA 0  T  1  -  - - -   - 0 -   -    T -> R1          1 B   OR  DZ 0  -  T  -  - - -   S 0 POP -    STK -> T          0 #INIT      T             - JSR              INIT          1 -   OR  ZA 0  12 -  -  - - -   - 0 MAR ALU  R12 -> MAR          1 B   OR  ZA 0  4  3  -  - - -   - 0 -   -    R4 -> R3          1 B   OR  DZ 0  -  7  -  - - -   - 0 ALU MD   MD -> R7          1 B   +   ZA 1  1  1  -  - - -   - 0 MAR ALU  R1 + 1 -> MAR -> R1          1 B   OR  DZ 0  -  12 -  - - -   - 0 ALU MD   MD -> R12*         (* COMPUTE MASKS, INCREMENT-STEPS AND BITPOSITION (FOR ALIGNEMENT) *) *             IF SY > DY*             THEN       (* DOWN MOVE, THE TRANSFER STARTS WITH THE BOTTOM*                           LINE OF THE BLOCK, ..*     (BMW < 0)            *)*               DBMW := -DBMW;*               SBMW := -SBMW;*               SRCY := SY + 1;                         7 : SRCY*               DSTY := DY + 1;                         8 : DSTY          1 -   -   AB 1  7  10 -  - - -   - 0 -   -    R7-R10          0 #UP        S             - JMP              GOTO UP IF <0           1 B   -   ZA 1  3  3  -  - - -   - 0 -   -    -R3 -> R3          1 B   -   ZA 1  12 12 -  - - -   - 0 -   -    -R12 -> R12          1 B   +   ZA 1  7  7  -  - - -   - 0 -   -    R7+1 -> R7          1 B   +   ZA 1  10 10 -  - - -   - 0 -   -    R10+1 -> R10          0 #HORIZ     T             - JMP              GOTO HORIZ*             ELSE       (* UP MOVE, START WITH THE TOP LINE OF THE BLOCK*                                                      (BMW > 0)             *) *               SRCY := SY + DH;                        7 : SRCY*               DSTY := DY + DH;                        8 : DSTY*             END;#UP       1 B   +   AB 0  11 7  -  - - -   - 0 -   -    R11+R7 -> R7          1 B   +   AB 0  11 10 -  - - -   - 0 -   -    R11+R10 -> R10$*             SBMHEIGHT := SBMD.H + 2*             SBMH := SBMHEIGHT - SRCY;                 T: SBMH*             DBMH := DBMHEIGHT - DSTY;                 8: DBMH#HORIZ    1 -   +   ZA 1  1  -  -  - - -   - 0 MAR ALU  R1 + 1 -> MAR           1 -   OR  ZA 0  3  -  -  - - -   S 0 PSH -    R3 -> STK          1 -   OR  ZA 0  12 -  -  - - -   S 0 PSH -    R12 -> STK          1 B   OR  DZ 0  -  T  -  - - -   - 0 ALU MD   MD -> T          1 B   +   DA 0  T  T  -  - - -   - 1 2        T + 2 -> T          1 B   -+  AB 1  7  T  -  - - -   - 0 -   -    T - R7 -> T          1 B   -   AB 1  2  10 -  - - -   - 0 -   -    R2 - R10 -> R10*             IF SX < DX*             THEN       (* RIGHT MOVE, THE LINES ARE TRANSFERED FROM RIGHT*                           TO LEFT (HORIZ = -1)                             *) *               HORIZ := -1;                            3 : HORIZ*               MASK3 := COMPL(MSK(0,DX MOD 16));       7 : MASK3*               SBIT := SX + DW;                        5 : SBIT*               DBIT := DX + DW;                        6 : DBIT*               MASK1 := MSK(0,DBIT MOD 16);            G : MASK1*               SR := (DBIT-SBIT) MOD 16;*               MASK2 := MSK(0,SR);                     L : MASK2*               WORDS := DBIT DIV 16 - DX DIV 16;       H : WORDS          1 -   -   AB 1  5  6  -  - - -   - 0 -   -    R5-R6          0 #LEFT      -S            - JMP              GOTO LEFT IF >=0          1 B   -+  DZ 1  -  3  -  - - -   - 1 1        -1 -> R3          1 -   OR  ZA 0  6  -  -  - - -   - 0 SR  ALU  R6 -> SR          1 B   -XR DZ 0  -  7  MR - - -   - 1 0        _MSK(0,SR) -> R7          1 B   +   AB 0  H  5  -  - - -   - 0 -   -    H+R5 -> R5          1 B   +   AB 0  H  6  -  - - -   - 0 SR  ALU  H+R6 -> R6 -> SR          1 B   OR  DZ 0  -  G  MR - - -   - 1 0        MSK(0,SR) -> G          1 -   -   AB 1  6  5  -  - - -   - 0 SR  ALU  R6-R5 -> SR          1 B   OR  DZ 0  -  L  MR - - -   - 1 0        MSK(0,SR) -> L          1 B   -   AB 1  6  H  -  - - -   - 0 -   -    R6 - H -> H  (DX)          1 B*  &   DQ 0  H  H  R  4 - -   - 0 ALU ALU  (H^4) & Q -> H          1 B*  &   DQ 0  6 12  R  4 - -   - 0 ALU ALU  (R6^4) & Q -> R12          1 B   -   AB 1 12  H  -  - - -   - 0 -   -    R12 - H -> H          1 B   -+  ZA 0  5  5  -  - - -   - 0 -   -    DEC(R5)          0 #ENDIF     T             - JMP              GOTO ENDIF$*             ELSE    (* LEFT MOVE, THE LEFTMOST WORD OF THE LINES IN THE*                        BLOCK ARE TRANSFERED FIRST (HORIZ = 1)            *)*               HORIZ := 1;                             3 : HORIZ*               SBIT := SX;                             5 : SBIT*               DBIT := DX;                             6 : DBIT*               MASK3 := MSK(0,(DBIT+DW) MOD 16);       7 : MASK3*               IF MASK3 = 0 THEN MASK3 := FFFF;*               MASK1 := COMPL(MSK(0,DBIT MOD 16));     G : MASK1*               SR := (DBIT-SBIT) MOD 16;*               MASK2 := COMPL(MSK(0,SR);               L : MASK2*               WORDS := ((DW + (DBIT MOD 16) - 1)*                        DIV 16);                       H : WORDS*             END;#LEFT     1 B   OR  DZ 0  -  3  -  - - -   - 1 1        1 -> R3          1 -   +   AB 0  6  H  -  - - -   - 0 SR  ALU  R6+H -> SR          1 B   OR  DZ 0  -  7  MR - - -   - 1 0        MSK(0,SR) -> 7          0 #L         -Z            - JMP              IF 7 <> 0           1 B   -+  ZA 0  7  7  -  - - -   - 0 -   -    7 - 1 -> 7#L        1 -   OR  ZA 0  6  -  -  - - -   - 0 SR  ALU  R6 -> SR          1 B   -XR DZ 0  -  G  MR - - -   - 1 0        MSK(0,SR) -> G          1 -   -   AB 1  6  5  -  - - -   - 0 SR  ALU  R6-R5 -> SR          1 B   -XR DZ 0  -  L  MR - - -   - 1 0        MSK(0,SR ) -> L          1 B   &   DA 0  6  12 -  - - -   - 1 17       17 & R6 -> R12          1 B   +   AB 0  12 H  -  - - -   - 0 -   -    R12 + H -> H          1 B   -+  ZA 0  H  H  -  - - -   - 0 -   -    H - 1 -> H          1 B*  &   DQ 0  H  H  R  4 - -   - 0 ALU ALU  (H^4) & Q -> H*            SWORD := SBMA * SBIT DIV 16 +               1 : SWORD*                     SBMH * SBMWIDTH;*            (* SOURCE-WORD-address, WHERE THE TRANSFER STARTS *)*            DWORD := DBMA + DBIT DIV 16 +               2 : DWORD*                     DBMH * DBMWIDTH;*            (* CORRESPONDING DESTINATION-WORD-ADDRESS *)*            SBANK := SBMA MOD 4;                        4 : SBANK*            DBANK := DBMA MOD 4;                        T : DBANK#ENDIF    1 -   OR  ZA 0  1  -  -  - - -   - 0 MAR ALU  R1 -> MAR          1 Q   OR  DZ 0  -  -  -  - - -   - 0 ALU MD   MD -> Q          1 -   -+  ZA 0  1  -  -  - - -   - 0 MAR ALU  R1 - 1 -> MAR          0 #MUL16     T             - JSR              Q * T -> Q  (-2-)          1 B   OR  DZ 0  -  P  -  - - -   - 0 ALU MD   MD -> P          1 B   -&  DA 0  P  1  -  - - -   - 1 3        3 & P -> R1          1 Q   +   AQ 0  1  -  -  - - -   - 0 -   -    R1 + Q -> Q          1 B   -&  DA 0  5  5  -  - - -   - 1 17       _17 & R5 -> R5          1 B*  +   DQ 0  5  1  R  4 - -   - 0 ALU ALU  (R5^4) + Q -> R1          1 B   OR  ZA 0  10 T  -  - - -   - 0 -   -    R10 -> T          1 Q   OR  ZA 0  4  -  -  - - -   - 0 -   -    R4 -> Q          0 #MUL16     T             - JSR              Q * T -> Q  (-2-)          1 B   &   DA 0  S  T  -  - - -   - 1 3        3 & S -> T          1 B   &   DA 0  P  4  -  - - -   - 1 3        3 & P -> R4          1 B   -&  DA 0  S  S  -  - - -   - 1 3        _3 & S -> S          1 Q   +   AQ 0  S  -  -  - - -   - 0 -   -    S + Q -> Q          1 B   -&  DA 0  6  6  -  - - -   - 1 17       _17 & R6 -> R6          1 B*  +   DQ 0  6  2  R  4 - -   - 0 ALU ALU  (R6^4)+Q -> R2$*             WHILE DH > 0 DO  (* LOOP FOR THE LINES OF THE BLOCK *)*               DEC(DH);*               W := WORDS;                             8 : W*               SA := SWORD;  (* SRC-ADDRESS *)         P : SA*               DA := DWORD;  (* DEST-ADDRESS *)        S : DA*               STK1 := M[DA];#WHILE.DH 1 B   -+  ZA 0  11 11 -  - - -   - 0 -   -    R11-1 -> R11          0 #ENDBBLT   F             - JMP              JMP END IF < 0          1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 B   OR  ZA 0  2  S  -  - - -   - 0 MAR ALU  R2 -> S -> MAR          1 B   OR  ZA 0  H  10 -  - - -   - 0 -   -    H -> R10          1 B   OR  ZA 0  1  12 -  - - -   - 0 -   -    R1 -> R12          1 -   OR  DZ 0  -  -  -  - - -   S 0 ALU MD   MD -> STK          1 -   &   ZQ 0  -  -  -  - - -   S 0 PSH -    0 -> STK*               IF (MASK1 OR MASK2) <> MASK2*               THEN STK0 := ROT(M[SA],SR) AND NOT MASK2;*                 SA := SA + HORIZ;*               ELSE STK0 := 0 END;          1 Q   OR  AB 0  L  G  -  - - -   - 0 -   -    L OR G -> Q          1 -   -   AQ 1  L  -  -  - - -   - 0 -   -    L - Q          0 #ELSE      Z             - JMP              IF = 0          1 -   OR  ZA 0  4  -  -  - - -   - 0 BNK ALU  R4 -> BNK          1 B*  OR  DZ 0  12 6  -  - - -   S 0 MAR ALU  R12 -> MAR,.                                                       STK -> R6 (DUMMY)          1 B   +   AB 0  3  12 -  - - -   - 0 -   -    R3+R12 -> R12           1 Q   -XR ZA 0  L  -  -  - - -   - 0 -   -    _L -> Q          1 -   &   DQ 0  -  -  RR - - -   S 0 ALU MD   (MD^SR) & Q -> STK*               R6 := ROT(M[SA],SR);                    6 : R6*               R5 := (STK0 OR (MASK2 AND R6)) AND MASK1; 5 : R5#ELSE     1 -   OR  ZA 0  4  -  -  - - -   - 0 BNK ALU  R4 -> BNK          1 -   OR  ZA 0  12 -  -  - - -   - 0 MAR ALU  R12 -> MAR          1 B   OR  DZ 0  -  6  RR - - -   - 0 ALU MD   (MD^SR) -> R6           1 Q   &   AB 0  L  6  -  - - -   - 0 -   -    L&R6 -> Q          1 B   OR  DQ 0  -  5  -  - - -   S 0 POP -    STK OR Q -> R5          1 B   &   AB 0  G  5  -  - - -   - 0 -   -    G AND R5 -> R5*               CASE MODE OF          1 -   -+  DA 1  0  -  -  - - -   - 1 2        R0-2          0 #INVERT    Z             - JMP              JMP INVERT IF =0          0 #ERASE     -F            - JMP              JMP ERASE IF >0          1 -   OR  ZA 0  0  -  -  - - -   - 0 -   -    R0          0 #PAINT     -Z            - JMP              JMP PAINT IF #0$*               0: (* REPLACE, DEST := SOURCE *)*                 R5 := R5 OR (STK1 AND NOT MASK1);*                 WHILE W > 0 DO  (* LOOP OVER THE WORDS OF A LINE *) *                   M[DA] :=R5;*                   DA := DA + HORIZ;          1 Q   -XR ZA 0  G  -  -  - - -   - 0 -   -    _G -> Q          1 Q   &   DQ 0  -  -  -  - - -   S 0 POP -    STK & Q -> Q          1 B   OR  AQ 0  5  5  -  - - -   - 0 -   -    R5 OR Q -> R5           1 -   OR  ZA 0  10 -  -  - - -   - 0 -   -    R10           0 #ENDLP0    Z             - JMP              JMP ENDLP0 IF =0#REPLACE  1 -   OR  ZA 0  5  -  -  - - -   - 0 MD  ALU  R5 -> MD          1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 -   OR  ZA 0  S  -  -  - - -   - 0 MAR ALU  S -> MAR          1 B   +   AB 0  3  S  -  - - -   - 0 -   -    R3+S -> S*                   SA := SA + HORIZ;*                   STK0 := R6 AND NOT MASK2;*                   R6 := ROT(M[SA],SR);*                   R5 := STK0 OR (R6 AND MASK2); *                   W := W - 1;*                 END; (* WHILE *)          1 -   OR  ZA 0  4  -  -  - - -   - 0 BNK ALU  R4 -> BNK          1 B   +   AB 0  3  12 -  - - -   - 0 MAR ALU  R3+R12 -> R12 -> MAR          1 -   -&  AB 0  L  6  -  - - -   S 0 PSH -    _L & R6 -> STK          1 B   OR  DZ 0  -  6  RR - - -   - 0 ALU MD   (MD^SR) -> R6           1 Q   &   AB 0  6  L  -  - - -   - 0 -   -    R6 & L -> Q          1 B   OR  DQ 0  -  5  -  - - -   S 0 POP -    STK OR Q -> R5          1 B   -+  ZA 0  10 10 -  - - -   - 0 -   -    R10-1 -> R10          0 #REPLACE   -Z            - JMP              GOTO REPLACE IF #0*                 M[DA] := (MASK3 AND R5) OR (M[DA] AND NOT MASK3) /#ENDLP0   1 B   &   AB 0  7  5  -  - - -   - 0 -   -    7 & R5 -> R5          1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 -   OR  ZA 0  S  -  -  - - -   - 0 MAR ALU  S -> MAR          1 Q   -XR ZA 0  7  -  -  - - -   - 0 -   -    _R7 -> Q          1 B   &   DQ 0  -  6  -  - - -   - 0 ALU MD   MD & Q -> R6          1 -   OR  AB 0  5  6  -  - - -   - 0 MD  ALU  R5 OR R6 -> MD          0 #ENDCASE   T             - JMP              GOTO ENDCASE$*               1: (* PAINT, DEST := DEST OR SOURCE *)*                 WHILE W > 0 DO  (* LOOP OVER THE WORDS OF A LINE *) *                   M[DA] := STK1 OR R5;*                   DA := DA + HORIZ;*                   STK1 := M[DA];#PAINT    1 -   OR  ZA 0  10 -  -  - - -   - 0 -   -    R10           0 #ENDLP1    Z             - JMP              GOTO ENDLP1 IF =0#WHILE1   1 -   OR  DA 0  5  -  -  - - -   S 0 MD  ALU  STK OR R5 -> MD          1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 -   OR  ZA 0  S  -  -  - - -   - 0 MAR ALU  S -> MAR          1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 B   +   AB 0  3  S  -  - - -   - 0 MAR ALU  R3+S -> S -> MAR          1 -   OR  DZ 0  -  -  -  - - -   S 0 ALU MD   MD -> STK*                   STK0 := NOT MASK2 AND R6;*                   SA := SA + HORIZ;*                   R6 := ROT(M[SA],SR);*                   R5 := STK0 OR (R6 AND MASK2); *                   W := W - 1;*                 END; (* WHILE *)          1 -   OR  ZA 0  4  -  -  - - -   - 0 BNK ALU  R4 -> BNK          1 B   +   AB 0  3  12 -  - - -   - 0 MAR ALU  R3+R12 -> R12 -> MAR          1 -   -&  AB 0  L  6  -  - - -   S 0 PSH -    _L & R6 -> STK          1 B   OR  DZ 0  -  6  RR - - -   - 0 ALU MD   (MD^SR) -> R6           1 Q   &   AB 0  6  L  -  - - -   - 0 -   -    R6 & L -> Q          1 B   OR  DQ 0  -  5  -  - - -   S 0 POP -    STK OR Q -> R5          1 B   -+  ZA 0  10 10 -  - - -   - 0 -   -    R10-1 -> R10          0 #WHILE1   -Z             - JMP              GOTO WHILE1 IF #0*                 M[DA] := STK1 OR (R5 AND MASK3)  /#ENDLP1   1 B   &   AB 0  7  5  -  - - -   - 0 -   -    R7 & R5 -> R5           1 -   OR  DA 0  5  -  -  - - -   S 0 MD  ALU  STK OR R5 -> MD          0 #ENDCASE   T             - JMP              GOTO ENDCASE$*               2: (* INVERT, DEST := DEST XOR SOURCE *)*                 WHILE W > 0 DO (* LOOP OVER THE WORDS OF A LINE *)*                   M[DA] := STK1 XOR R5;*                   DA := DA + HORIZ;*                   STK1 := M[DA];#INVERT   1 -   OR  ZA 0  10 -  -  - - -   - 0 -   -    R10           0 #ENDLP2    Z             - JMP              GOTO ENDLP2 IF =0#WHILE2   1 -   XOR DA 0  5  -  -  - - -   S 0 MD  ALU  STK XOR R5 -> MD          1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 -   OR  ZA 0  S  -  -  - - -   - 0 MAR ALU  S -> MAR          1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 B   +   AB 0  3  S  -  - - -   - 0 MAR ALU  R3+S -> S -> MAR          1 -   OR  DZ 0  -  -  -  - - -   S 0 ALU MD   MD -> STK*                   SA := SA + HORIZ;*                   STK0 := NOT MASK2 AND R6;*                   R6 := ROT(M[SA],SR);*                   R5 := STK0 OR (R6 AND MASK2); *                   W := W - 1;*                 END; (* WHILE *)          1 -   OR  ZA 0  4  -  -  - - -   - 0 BNK ALU  R4 -> BNK          1 B   +   AB 0  3  12 -  - - -   - 0 MAR ALU  R3+R12 -> R12 -> MAR          1 -   -&  AB 0  L  6  -  - - -   S 0 PSH -    _L & R6 -> STK          1 B   OR  DZ 0  -  6  RR - - -   - 0 ALU MD   (MD^SR) -> R6           1 Q   &   AB 0  6  L  -  - - -   - 0 -   -    R6 & L -> Q          1 B   OR  DQ 0  -  5  -  - - -   S 0 POP -    STK OR Q -> R5          1 B   -+  ZA 0  10 10 -  - - -   - 0 -   -    R10-1 -> R10          0 #WHILE2   -Z             - JMP              GOTO WHILE2 IF #0*                 M[DA] := STK1 XOR (R5 AND MASK3)  /#ENDLP2   1 B   &   AB 0  7  5  -  - - -   - 0 -   -    R7 & R5 -> R5           1 -   XOR DA 0  5  -  -  - - -   S 0 MD  ALU  STK XOR R5 -> MD          0 #ENDCASE   T             - JMP              GOTO ENDCASE$*               3: (* ERASE, DEST := NOT SOURCE AND DEST *) *                 WHILE W > 0 DO  (* LOOP OVER THE WORDS OF A LINE *) *                   M[DA] := NOT R5 AND STK1;*                   DA := DA + HORIZ;*                   STK1 := M[DA];#ERASE    1 -   OR  ZA 0  10 -  -  - - -   - 0 -   -    R10           0 #ENDLP3    Z             - JMP              GOTO ENDLP3 IF =0#WHILE3   1 Q   OR  DZ 0  -  -  -  - - -   S 0 POP -    STK -> Q          1 -   -&  AQ 0  5  -  -  - - -   - 0 MD  ALU  _R5 & Q -> MD           1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 -   OR  ZA 0  S  -  -  - - -   - 0 MAR ALU  S -> MAR          1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 B   +   AB 0  3  S  -  - - -   - 0 MAR ALU  R3+S -> S -> MAR          1 -   OR  DZ 0  -  -  -  - - -   S 0 ALU MD   MD -> STK*                   SA := SA + HORIZ;*                   STK0 := NOT MASK2 AND R6;*                   R6 := ROT(M[SA],SR);*                   R5 := STK0 OR (R6 AND MASK2); *                   W := W - 1;*                 END; (* WHILE *)          1 -   OR  ZA 0  4  -  -  - - -   - 0 BNK ALU  R4 -> BNK          1 B   +   AB 0  3  12 -  - - -   - 0 MAR ALU  R3+R12 -> R12 -> MAR          1 -   -&  AB 0  L  6  -  - - -   S 0 PSH -    _L & R6 -> STK          1 B   OR  DZ 0  -  6  RR - - -   - 0 ALU MD   (MD^SR) -> R6           1 Q   &   AB 0  6  L  -  - - -   - 0 -   -    R6 & L -> Q          1 B   OR  DQ 0  -  5  -  - - -   S 0 POP -    STK OR Q -> R5          1 B   -+  ZA 0  10 10 -  - - -   - 0 -   -    R10 - 1 -> R10          0 #WHILE3   -Z             - JMP              GOTO WHILE3 IF #0*                 M[DA] := NOT (MASK3 AND R5) AND STK1#ENDLP3   1 B   &   AB 0  7  5  -  - - -   - 0 -   -    R7 & R5 -> R5           1 Q   OR  DZ 0  -  -  -  - - -   S 0 POP -    STK -> Q          1 -   -&  AQ 0  5  -  -  - - -   - 0 MD  ALU  _R5 & Q -> MD *               END; (* CASE *);*               SWORD := SWORD + SBMW;  *               DWORD := DWORD + DBMW;  *             END; (* WHILE DH > 0 *)#ENDCASE  1 -   OR  ZA 0  T  -  -  - - -   - 0 BNK ALU  T -> BNK          1 -   OR  ZA 0  S  -  -  - - -   - 0 MAR ALU  S -> MAR          1 B   OR  DZ 0  -  5  -  - - -   S 0 POP -    STK -> R5          1 B   OR  DZ 0  -  12 -  - - -   S 0 POP -    STK -> R12          1 B*  +   AB 0  12 2  -  - - -   S 0 PSH -    R12 -> STK, R12+R2 -> R2          1 B*  +   AB 0  5  1  -  - - -   S 0 PSH -    R5 -> STK, R5 + R1 -> R1          0 #WHILE.DH  T             - JMP              END BIG WHILE #ENDBBLT  0 EXITBBLT   T             - JSR              RESTORE REGS          1 Q   OR  DZ 0  -  -  -  - S JMP - 0 ALU IR4  JMAP*           POP(S); *           POP(P); *           POP(H); *           POP(G); *           POP(L); *           POP(M); *           POP(T); *         END BBLT; ***$