(*********************************                               * *    WindowDialogue             **    **************             **                               **    Version 2   14.12.81       **                               **    Christian Jacobi           * *    Institut fuer Informatik   **    ETH-Zuerich                **    CH-8092 Zuerich            **                               *********************************) IMPLEMENTATION MODULE WindowDialogue;  (* Ch. Jacobi 14.12.81*)  FROM Terminal IMPORT Write, WriteString, WriteLn, Read, BusyRead, ReadAgain;  FROM WindowHandler IMPORT Window, FullScreen, BlockDescriptor, SignalSet,     LoadFont, DefaultWindow, UseForDefault, OpenWindow, CreateWindow,    CloseWindow, ChangeWindow, PutOnTop, WindowSignal, WindowProc,    SelectWindow, GetPos, IgnoreWindowSignal, NextDown;  FROM FileNames IMPORT ReadFileName, IdentifierPosition;  FROM Program IMPORT Call, Status;  FROM ProgramMessage IMPORT WriteStatus;  FROM SEK IMPORT CallComint;  FROM Monitor IMPORT TermProcedure, CurrentLevel, SharedLevel;  FROM CursorStuff IMPORT TrackCursor, MenuSelection, xpos, ypos, ReleaseCursor,                          InstallCursor, SimpleMove;  FROM Screen IMPORT Bitmap, GetSystemBitmap, GetMaxBlock, Replicate, Mode;  (*$T-*)  (*$R-*)(*****************************************)(*   Dialog Loop                         *)(*****************************************)             CONST     max = 16;    levelmax = 6;    enableShared = 15;  TYPE    ControlRecord =      RECORD         sw: Window;           da: BITSET;         (*allowed dialog actions*)        diaHP: DialogProc;        ca: SignalSet;         lev, slev: CARDINAL       END;  VAR    stack: ARRAY [1..max] OF ControlRecord;    top: [0..max]; (*points to top element in stack*)    callReason: CARDINAL;    calledWindow: Window;    level: CARDINAL;    stop: BOOLEAN;         (*stops the dialog*)    keyboardproc: PROC;    keyboardlevel: CARDINAL;    keyboardtop: CARDINAL;    keyboardstack: ARRAY [0..levelmax] OF       RECORD proc: PROC; lev: CARDINAL END;      but: BITSET;    yToCallWindoweditor: CARDINAL;    recursivecomint: BOOLEAN;      (* reset on level return by caller;                                      this module is thought to be only caller *)  PROCEDURE EmptyDialogProc(w: Window; c: CARDINAL);  BEGIN  END EmptyDialogProc;  PROCEDURE Skip;    VAR ch: CHAR;  BEGIN    BusyRead(ch)  END Skip;  PROCEDURE DialogLoop(comint: BOOLEAN);    VAR      i: CARDINAL;      found, outcomint: BOOLEAN;  BEGIN    IF NOT recursivecomint THEN comint := FALSE END;    outcomint := recursivecomint; recursivecomint := comint;    level := SharedLevel();    stop := FALSE;    REPEAT      callReason := TrackCursor();      IF callReason=0 THEN keyboardproc()      ELSE        IF ypos=yToCallWindoweditor THEN WindowEditor        ELSE          SelectWindow(calledWindow, xpos, ypos, found);          IF NOT found THEN WindowEditor          ELSE (*found*)            i := top;            LOOP               IF i=0 THEN EXIT END;              WITH stack[i] DO                 IF (sw=calledWindow) AND (callReason IN da)                   AND ((SharedLevel()=slev) OR (enableShared IN da)) THEN                         stack[i].diaHP(calledWindow, callReason);                        EXIT                END              END;              DEC(i);            END;            ReleaseCursor(FALSE, but);          END;         END;      END    UNTIL stop;    recursivecomint := outcomint;    level := SharedLevel();    stop := FALSE;  END DialogLoop;  PROCEDURE EndLoop;  BEGIN    stop := SharedLevel()<=level   END EndLoop;  PROCEDURE ResetFromOverlayReturn;    VAR i, j: CARDINAL;  BEGIN     WHILE (top>0) AND (stack[top].lev>=CurrentLevel()) DO      DEC(top)    END;    WHILE (keyboardlevel>=CurrentLevel()) AND (keyboardlevel>0) DO      keyboardproc := keyboardstack[keyboardtop-1].proc;      keyboardlevel := keyboardstack[keyboardtop-1].lev;      DEC(keyboardtop);    END  END ResetFromOverlayReturn;   PROCEDURE InstallKeyboard(p: PROC);  BEGIN    IF CurrentLevel()>keyboardlevel THEN      IF keyboardtop>levelmax THEN HALT END;      keyboardstack[keyboardtop].proc := keyboardproc;      keyboardstack[keyboardtop].lev := keyboardlevel;      INC(keyboardtop);      keyboardlevel := CurrentLevel();    END;    keyboardproc := p;  END InstallKeyboard;  PROCEDURE RemoveWindow(w: Window);    VAR i, j: CARDINAL;  BEGIN     FOR i := top TO 1 BY -1 DO (*do not remove the missing entry #0*)      IF stack[i].sw=w THEN        IF stack[i].slev<SharedLevel() THEN RETURN END;        FOR j := i+1 TO top DO stack[j-1] := stack[j] END;        DEC(top)      END    END;  END RemoveWindow;  PROCEDURE InstallWindow(w: Window;               dialogActions: BITSET; dialogHandler: DialogProc;              controlActions: SignalSet;  (*these actions are caused by the dialog*)              VAR done: BOOLEAN);  BEGIN    done := top<max;    IF done THEN       INC(top);      WITH stack[top] DO        sw := w;         da := dialogActions;         ca := controlActions;         diaHP := dialogHandler;        lev := CurrentLevel();  (*used for deletion since code disapears*)        slev := SharedLevel();  (*used to forbid actions*)      END;    END  END InstallWindow;  PROCEDURE CreateInstallWindow(VAR w: Window; name: ARRAY OF CHAR;              dialogActions: BITSET; dialogHandler: DialogProc;              controlActions: SignalSet;  (*these actions are caused by the dialog*)              savebitwise:    BOOLEAN;              signal: WindowProc;              VAR done: BOOLEAN);    VAR      b : BlockDescriptor;      ch: CHAR;   BEGIN    REPEAT      REPEAT        WriteString('input the diagonal' ); WriteLn;        InputBlock(b, done);        IF NOT done THEN          BusyRead(ch);           IF ch=33C THEN RETURN END         END;      UNTIL done;      CreateWindow(w, b.x, b.y, b.w, b.h, name,         savebitwise, signal, done);      IF done THEN WriteString('opened')      ELSE WriteString('not done, repeat' )       END;      WriteLn;    UNTIL done;    InstallWindow(w, dialogActions, dialogHandler, controlActions, done);    IF NOT done THEN CloseWindow(w) END  END CreateInstallWindow;(*****************************************)(*   Window Editor                       *)(*****************************************)             VAR    cursorOn: BOOLEAN;    xpos1, ypos1: CARDINAL; (*first position of a block;                               if only move then height*)    xpos2, ypos2: CARDINAL; (*second position of a block for change,                               position for move*)    width, height: CARDINAL;(*of full screen*)    fullbm: Bitmap;    PROCEDURE CrossInvert;      VAR b: BlockDescriptor;    BEGIN       IF cursorOn THEN cursorOn := FALSE      ELSE cursorOn := TRUE;        xpos1 := xpos; ypos1 := ypos;        IF xpos1>=width THEN xpos1 := width-1 END;        IF ypos1>=height THEN ypos1 := height-1 END;      END;      WITH b DO x := xpos1; y := 0; w := 1; h := height END;      Replicate(fullbm, b, invert, black);      WITH b DO x := 0; y := ypos1; w := width; h := 1 END;      Replicate(fullbm, b, invert, black);    END CrossInvert;    PROCEDURE BlockChangeInvert;      VAR b: BlockDescriptor;    BEGIN       IF cursorOn THEN cursorOn := FALSE      ELSE cursorOn := TRUE;        xpos2 := xpos; ypos2 := ypos;        IF xpos2>=width THEN xpos2 := width-1 END;        IF ypos2>=height THEN ypos2 := height-1 END;      END;      WITH b DO        x := xpos2; w := 1;         IF ypos2>=ypos1 THEN h := 1+ypos2-ypos1; y := ypos1;         ELSE y := ypos2; h := 1+ypos1-ypos2         END;        Replicate(fullbm, b, invert, black);        x := xpos1;         Replicate(fullbm, b, invert, black);        y := ypos2; h := 1;        IF xpos2>=xpos1 THEN x := xpos1; w := 1+xpos2-xpos1;        ELSE x := xpos2; w := 1+xpos1-xpos2;          END;        Replicate(fullbm, b, invert, black);        y := ypos1;        Replicate(fullbm, b, invert, black);      END;    END BlockChangeInvert;    PROCEDURE BlockMoveInvert;      VAR b: BlockDescriptor;    BEGIN       IF cursorOn THEN cursorOn := FALSE      ELSE cursorOn := TRUE;        xpos2 := xpos; ypos2 := ypos;        IF xpos2>width-xpos1 THEN xpos2 := width-xpos1 END;        IF ypos2>height-ypos1 THEN ypos2 := height-ypos1 END;      END;      WITH b DO        w := 1; h := ypos1;        x := xpos2; y := ypos2;         Replicate(fullbm, b, invert, black);        x := xpos2+xpos1-1;         Replicate(fullbm, b, invert, black);        w := xpos1; h := 1;        x := xpos2; y := ypos2;         Replicate(fullbm, b, invert, black);        y := ypos2+ypos1-1;          Replicate(fullbm, b, invert, black);      END;    END BlockMoveInvert;  PROCEDURE InputBlock(VAR b: BlockDescriptor; VAR done: BOOLEAN);    VAR       i1, i2, sx, sy: CARDINAL;      but: BITSET;  BEGIN     InstallCursor(CrossInvert, SimpleMove);    done := TrackCursor()<>0;    IF done THEN       i1 := xpos; i2 := ypos;      InstallCursor(BlockChangeInvert, SimpleMove);      ReleaseCursor(FALSE, but);      done := NOT (0 IN but) AND done;      IF i1 < xpos THEN b.x := i1 ELSE b.x := xpos END;      IF i2 < ypos THEN b.y := i2 ELSE b.y := ypos END;      b.w := ABS(INTEGER(i1) - INTEGER(xpos))+1;      b.h := ABS(INTEGER(i2) - INTEGER(ypos))+1;    END  END InputBlock;  PROCEDURE WindowEditor;            PROCEDURE EliminateDevice(VAR s: ARRAY OF CHAR);      VAR n, i: CARDINAL;    BEGIN      n := IdentifierPosition(s, 1); i := n;      WHILE i<=HIGH(s) DO        s[i-n] := s[i];        INC(i);      END;      IF (i-n)<=HIGH(s) THEN s[i-n] := 0C END;    END EliminateDevice;    PROCEDURE SelectWindowNumber(dialog: BITSET; oper: SignalSet): CARDINAL;      (* returns 0 if not legaly selected *)      VAR         butno: CARDINAL;         i: CARDINAL;        found: BOOLEAN;        w: Window;        ch: CHAR;    BEGIN      butno := TrackCursor();      IF butno IN {1..3} THEN         SelectWindow(w, xpos, ypos, found);        IF found THEN           found := FALSE;          ReleaseCursor(FALSE, but);          i := top;          LOOP            IF i=0 THEN EXIT END;            IF SharedLevel()>stack[i].slev THEN              found := TRUE; EXIT             END;            IF stack[i].sw=w THEN              IF ((dialog*stack[i].da)<>{})                   OR ((oper*stack[i].ca)<>SignalSet{}) THEN                 RETURN i              END;            ELSE found := TRUE            END;            DEC(i);          END (*loop*)        END (*if found*)      ELSE BusyRead(ch)      END;      IF found THEN WriteString("window not active"); WriteLn; END;      RETURN 0    END SelectWindowNumber;    PROCEDURE Exit;      VAR ch: CHAR;    BEGIN      WriteString("confirm exit (y/-)"); WriteLn;      Read(ch);      IF (ch="y") OR (ch="Y") THEN        WriteString(' yes'); EndLoop;      ELSE WriteString(' no') END;      WriteLn;    END Exit;    PROCEDURE MoveAWindow();      VAR         i2, index: CARDINAL;        done: BOOLEAN;        ch: CHAR;        but: CARDINAL;        w: Window;    BEGIN       WriteString("move which window"); WriteLn;      index := SelectWindowNumber({}, SignalSet{moved});      IF index=0 THEN RETURN END;      w := stack[index].sw;      done := FALSE;      xpos1 := w^.outerblk.w;      ypos1 := w^.outerblk.h;      REPEAT        WriteString('move '); WriteString(w^.header); WriteLn;        REPEAT          InstallCursor(BlockMoveInvert, SimpleMove);          but := TrackCursor();          IF 0=but THEN BusyRead(ch);             IF ch=33C THEN RETURN END           ELSE done := TRUE;          END;        UNTIL done;        ChangeWindow(w, xpos2, ypos2, xpos1, ypos1, done);        IF NOT done THEN WriteString(' repeat'); WriteLn END;      UNTIL done;    END MoveAWindow;    PROCEDURE ChangeAWindow();      VAR        index: CARDINAL;        b: BlockDescriptor;        done: BOOLEAN;        ch: CHAR;        w: Window;    BEGIN      WriteString("change which window"); WriteLn;      index := SelectWindowNumber({}, SignalSet{changed});      IF index=0 THEN RETURN END;      w := stack[index].sw;      REPEAT        WriteString('change window '); WriteString(w^.header); WriteLn;        REPEAT          WriteString('point the diagonal' ); WriteLn;          InputBlock(b, done);          IF NOT done THEN Read(ch);             IF ch=33C THEN RETURN END           END;        UNTIL done;        ChangeWindow(w, b.x, b.y, b.w, b.h, done);        IF NOT done THEN WriteString('repeat'); WriteLn; END;      UNTIL done;    END ChangeAWindow;    PROCEDURE ChangeAFont();      VAR         index: CARDINAL;        b: BlockDescriptor;         done: BOOLEAN;        ch: CHAR;        name: ARRAY [0..24] OF CHAR;        w: Window;    BEGIN      WriteString("which window"); WriteLn;      index := SelectWindowNumber({}, SignalSet{fontchanged});      IF index=0 THEN RETURN END;      w := stack[index].sw;      REPEAT        WriteString("font>");         ReadFileName(name, "DK"); Read(ch); Write(ch);        EliminateDevice(name);        LoadFont(w, name , done);        IF done THEN WriteString(' done')        ELSIF ch<>33c THEN WriteString('not done; repeat ');        END;        WriteLn;      UNTIL done OR (ch=33c);    END ChangeAFont;    PROCEDURE CallSelection;       PROCEDURE SharedCall;        VAR          ch: CHAR;          st: Status;          fn: ARRAY [0..24] OF CHAR;      BEGIN        WriteString("*** SHARED CALL ***"); WriteLn;        LOOP          REPEAT            Write("*");             ReadFileName(fn, "DK"); Read(ch);            IF (ch=33C) THEN              IF (fn[0]=0C) THEN                 WriteString("end shared comint"); WriteLn;                EXIT               ELSE WriteLn END;            ELSE Write(ch);            END;          UNTIL ch<>33C;          EliminateDevice(fn);          Call(fn, TRUE, st);          IF st<>normal THEN            WriteStatus(st); WriteLn;          END;        END;       END SharedCall;      PROCEDURE UtilityCall(w: Window);        VAR           st: Status;          ch: CHAR;           dw: Window;          line, pos: CARDINAL;      BEGIN        IF NOT recursivecomint THEN           WriteString("not allowed by program"); WriteLn;           RETURN        END;        dw := DefaultWindow();        UseForDefault(w);        GetPos(w, line, pos); IF pos<>0 THEN WriteLn END;        st := normal;        CASE MenuSelection("* CALL| dir| copy| delete| rename| list") OF          0: Read(ch);              IF ch=CHAR(1+ORD("s")-ORD("a")) THEN SharedCall             ELSE ReadAgain; PutOnTop(w);                WriteString("program or <esc>"); WriteLn;                CallComint(TRUE, st)             END|          2: Call("directory", FALSE, st)|          3: Call("copy", FALSE, st)|          4: Call("delete", FALSE, st)|          5: Call("rename", FALSE, st)|          6: Call("list", FALSE, st)          (*| 7: Call("writepicture", FALSE, st) *)          ELSE        END;        UseForDefault(dw);        IF st<>normal THEN WriteStatus(st); WriteLn END;        recursivecomint := TRUE;       END UtilityCall;      PROCEDURE NewCall;        VAR           temWin: Window;           done: BOOLEAN;          ch: CHAR;      BEGIN        CreateInstallWindow(temWin, "command interpreter",           {}, EmptyDialogProc,          SignalSet{},          TRUE, IgnoreWindowSignal,          done);        IF done THEN           UtilityCall(temWin);          RemoveWindow(temWin);          IF TrackCursor()=0 THEN BusyRead(ch) END;           CloseWindow(temWin)        END      END NewCall;      VAR         ch: CHAR;         myindex: CARDINAL;    BEGIN (*CallSelection*)      LOOP        WriteString("which window"); WriteLn;        myindex := SelectWindowNumber({4}, SignalSet{});        IF myindex>0 THEN EXIT         ELSE          CASE MenuSelection("window?| point| own") OF            0: Read(ch); EXIT|            2: |            3: NewCall; (*myindex=0*) EXIT          ELSE EXIT          END         END      END; (*loop*)      IF myindex>0 THEN         UtilityCall(stack[myindex].sw);         stack[myindex].diaHP(stack[myindex].sw, 4)      END    END CallSelection;    PROCEDURE RemoveAWindow;      VAR        diaproc: DialogProc;        w: Window;        index: CARDINAL;    BEGIN      WriteString("remove which window"); WriteLn;      index := SelectWindowNumber({5}, SignalSet{});      IF index>0 THEN         w := stack[index].sw;        diaproc := stack[index].diaHP;        RemoveWindow(w);        diaproc(w, 5)      END    END RemoveAWindow;    PROCEDURE PutWindowOnTop;      VAR w: Window; found: BOOLEAN;    BEGIN      SelectWindow(w, xpos+7, ypos+7, found);      IF found THEN PutOnTop(w) END;    END PutWindowOnTop;        PROCEDURE WindowOrder;      CONST max = 200; N = 24-1;      VAR         w, w1: Window;         s: ARRAY [0..max] OF CHAR;         i, j: CARDINAL;    BEGIN       s := "*PUT ON TOP|"; j := 11;      w := NextDown(NIL); i := 1; (*i=windowcount+1*)      WHILE w<>NIL DO INC(i); w := NextDown(w) END;       REPEAT w := NextDown(w); DEC(i) UNTIL i<=9; (*take only the 8 bottom windows*)      w1 := w;      IF w<>NIL THEN        LOOP                      (*i is local*)          i := 0;          WITH w^ DO            INC(j);            WHILE (i<=N) AND (header[i]=" ") DO INC(i) END;            WHILE (i<=N) AND (header[i]<>0C) AND (j<max) DO               s[j] := header[i]; INC(j); INC(i);            END;            s[j] := "|";           END;          w := NextDown(w);          IF (w=NIL) OR (j=max) THEN s[j] := 0C; EXIT END;        END;        i := MenuSelection(s);        IF i=1 THEN PutWindowOnTop        ELSE          FOR j := 3 TO i DO w1 := NextDown(w1) END;          IF w1<>NIL THEN PutOnTop(w1) END        END;      END    END WindowOrder;  BEGIN (*WindowEditor*)    CASE MenuSelection(" MAIN| exit| call| remove| move| change| font| order") OF      0: Skip|      1: PutWindowOnTop|      2: Exit|      3: CallSelection|      4: RemoveAWindow|      5: MoveAWindow|      6: ChangeAWindow|      7: ChangeAFont|      8: WindowOrder      ELSE    END;    ReleaseCursor(FALSE, but);  END WindowEditor;  VAR black: RECORD a, b: CARDINAL END;BEGIN  WITH black DO a := 1; b := 177777B END;  GetSystemBitmap(fullbm);  cursorOn := FALSE;  recursivecomint := TRUE;  top := 0;    (* temporary *) calledWindow := FullScreen();  width := calledWindow^.outerblk.w;  height := calledWindow^.outerblk.h;  yToCallWindoweditor := height-1;  keyboardtop := 0;  keyboardlevel := 0;  keyboardproc := Skip;  TermProcedure(ResetFromOverlayReturn)END WindowDialogue.