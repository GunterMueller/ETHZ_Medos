IMPLEMENTATION MODULE HermesLine;FROM SYSTEM IMPORT  TSIZE;FROM Terminal IMPORT  WriteString, WriteLn, Write;FROM CardinalIO IMPORT  WriteOct;FROM HermesByte IMPORT  TimeOut, TimeOutOn, SendByte, ReceiveByte, TimeOutLength;(*FROM Hermes IMPORT  debugOn;*)CONST flag = 137c;(*PROCEDURE DisplayPacket( VAR p : packet);  BEGIN   WriteOct(p.words[0]); WriteOct(p.words[1]);    WriteOct(p.words[2]); WriteOct(p.words[3]);   WriteOct(p.words[4]); WriteOct(p.words[5]); WriteLn;   WITH p DO    WriteString('length='); WriteOct(length);    WriteString(' xsum  ='); WriteOct(pxsum);    WriteString(' seqnr ='); WriteOct(seqnr); WriteLn;    WriteString('type  =');    CASE pt OF    AreYouHere : WriteString('are you here ') ;                 IF NOT IamMaster THEN WriteString(' no') END;                 WriteString(' master')     |    LastBadBlock: WriteString('last bad block') |    FileAction: WriteString('file action ') ;                CASE Fcmd OF                OpenWrite : WriteString('open write') |                OpenRead  : WriteString('open read')  |                CloseF    : WriteString('close file') |                CheckOpen :WriteString('check open')                ELSE WriteString('illegal command')                END;                WriteString(' filename=');                WriteString(fn); |    FileActionResult : WriteString('file result '); WriteResponse(Fres);  |    FileData:   WriteString('data');                WriteString(' #bytes='); WriteOct(nrbytes); WriteLn;                WriteOct(CARDINAL(buff[0])); WriteOct(CARDINAL(buff[1]));         |    NextData:   WriteString('next data ');                    |    Abort:      WriteString('abort:'); WriteString(p.msg)    |    Kill:       WriteString('KILL!!')    ELSE        WriteString('illegal type '); WriteOct(CARDINAL(pt))    END;    WriteLn;   END (*with*)  END DisplayPacket;*)   PROCEDURE PacketLength ( VAR p : packet) : CARDINAL;    (* compute the length of the packet *)    BEGIN      CASE p.pt OF      AreYouHere   : RETURN ( TSIZE(packet, three, AreYouHere  ))  |      LastBadBlock : RETURN ( TSIZE(packet, three, LastBadBlock))  |      FileAction   : RETURN ( TSIZE(packet, three, FileAction  ))  |      FileActionResult : RETURN ( TSIZE(packet, three, FileActionResult )) |      FileData     : RETURN ( TSIZE(packet, three, FileData    ))  |      NextData     : RETURN ( TSIZE(packet, three, NextData    ))  |      Abort        : RETURN ( TSIZE(packet, three, Abort       ))  |      Kill         : RETURN ( TSIZE(packet, three, Kill        ))      END    END PacketLength;  PROCEDURE PacketXsum ( VAR p : packet; VAR xs : CARDINAL);    (* compute the packet checksum *)    VAR i, pl, xsl : CARDINAL;    BEGIN xsl := p.length; pl := PacketLength(p) - 2;      FOR i := 1 TO pl DO        xsl := CARDINAL( BITSET(xsl) / (*XOR*) BITSET( p.words[i]))      END;      xs := xsl;    END PacketXsum;  PROCEDURE SkipPacket;     (* skip the rest of the packet *)    VAR b : CHAR;    BEGIN TimeOutOn := TRUE; TimeOutLength(8000h);      REPEAT ReceiveByte(b) UNTIL TimeOut;      TimeOutLength(0FFFFh)    END SkipPacket;   PROCEDURE transmit( VAR p : packet);    VAR i, pl : CARDINAL;    BEGIN pl := PacketLength(p); p.length := pl;      PacketXsum(p, p.pxsum);(*      IF debugOn THEN WriteString('.....xmit->');   DisplayPacket(p); END;*)      SendByte(flag);      SendByte( CHAR (pl));      FOR i := 0 TO 2*pl-3 DO SendByte(p.bytes[i]) END;    END transmit;  PROCEDURE receiv( VAR p : packet; VAR res : PacketResult;                     timeouton : BOOLEAN);    VAR b : CHAR; i, pl, xs : CARDINAL;    BEGIN      TimeOutOn := timeouton;      ReceiveByte( b );  (* wait flag *)      IF TimeOut THEN res := ptimeout; RETURN END;      IF b<>flag THEN SkipPacket; res := badflag; RETURN END;      TimeOutOn := TRUE; (*allways time out *)      ReceiveByte( b );  (* lenght *)      IF TimeOut THEN res := badpacket; RETURN END;      pl := 2 * CARDINAL(b)-2; p.length := CARDINAL(b);      i := 0;      LOOP         ReceiveByte(b); p.bytes[i] := b;        IF TimeOut THEN res := badpacket; RETURN END;        INC(i);        IF i = pl THEN res := pOK; EXIT END;      END;      PacketXsum(p, xs);      IF xs <> p.pxsum THEN res := badxsum END;    END receiv; PROCEDURE  receive( VAR p : packet; VAR res : PacketResult;                      timeouton : BOOLEAN);   BEGIN receiv(p, res, timeouton);(*     IF debugOn THEN       WriteString('....received->');  DisplayPacket(p);       WriteString('---');       CASE res OF       pOK      : WriteString('pOK')        |       badflag  : WriteString('bad flag')   |       ptimeout : WriteString('time out')   |       badpacket: WriteString('bad packet') |       badxsum  : WriteString('bad xsum')       END;       WriteLn;     END;*)     IF (res=pOK) AND (p.pt<>LastBadBlock) THEN Write('.')     ELSE Write('-')     END;   END receive; END HermesLine.