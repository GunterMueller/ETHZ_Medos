IMPLEMENTATION MODULE ScreenDriver2;  (* Ch. Jacobi *)   (* "TextScreenDriver" (resident)                              25.6.81 *)  (* "ScreenDriver"     (temporary imports "TextScreenDriver") 25.10.81 *)  (* "ScreenDriver2"    (imports "DisplayDriver")               12.6.82 *)  FROM SYSTEM IMPORT ADDRESS, ADR, WORD;  FROM Monitor IMPORT CurrentLevel, TermProcedure;  FROM TerminalBase IMPORT AssignWrite, WriteProcedure;  IMPORT (*DefaultFont,*) Frames;(**only non-resident**)IMPORT DisplayDriver;  (*$T-*)  (*$R-*)  CONST lockBitmap = FALSE;  (*to disable procedure DisplayDriver.ChangeBitmap*)  (****************************************************)  (* Hardware resources and initialization            *)  (****************************************************)  TYPE Mode =  (replace, paint, invert, erase);      VAR     white: RECORD leng, pat: CARDINAL END;  (*is constant*)    BMA: CARDINAL;                  (*frame pointer*)    initatlevel: CARDINAL;          (*return to this level is return to resident*)    b: BOOLEAN;(** if resident:    olddisplay: BOOLEAN;       aligned: ARRAY [0..6] OF CARDINAL;*)  PROCEDURE InitSys;  BEGIN     sysBMA := BMA;    sysF := (*DefaultFont.defaultFont*)DisplayDriver.DFF();    WITH sysBMD DO      bAdr       := ROR(sysBMA, 14);      bwidth     := maxWidth DIV 16;      bheigth    := maxHeight-2;      bposition  := 0;    END;  END InitSys;(*if resident  PROCEDURE CheckDisplay;    VAR displayCode: CARDINAL;  BEGIN     GET(74B, displayCode);    maxWidth  := (displayCode MOD 32 + 1) * 64;    maxHeight := (displayCode DIV 32 + 1) * 2;    olddisplay := (maxWidth>1024) OR (maxHeight>1024);    IF olddisplay THEN      maxHeight := 592;      maxWidth  := 768;    END;  END CheckDisplay;*)  PROCEDURE CheckDisplay;    VAR done: BOOLEAN;  BEGIN    maxHeight := DisplayDriver.MapHeight();    maxWidth := DisplayDriver.ScreenWidth();    IF lockBitmap THEN      DisplayDriver.ChangeBitmap(0, done);      IF NOT done THEN         DisplayDriver.ChangeBitmap(4*DisplayDriver.LineHeight(), done);      END    END  END CheckDisplay;(*resident version  PROCEDURE ShowBm(bmd: BitmapDescriptor);    VAR abmdp: POINTER TO BitmapDescriptor;  BEGIN    WITH bmd DO      IF (bheigth<=(maxHeight-2)) AND (bwidth<=(maxWidth DIV 16)) THEN        IF olddisplay THEN           IF ODD(bheigth) THEN INC(bheigth) END;          IF bwidth MOD 4 = 0 THEN            abmdp := ADDRESS( (ADR(aligned)+3) DIV 4 * 4);            abmdp^ := bmd;            PUT(0, abmdp);          END        ELSE            IF bwidth = (maxWidth DIV 16) THEN            PUT(75B, ROR(bmd.bAdr, 2));            PUT(74B, 1);          END        END      END    END  END ShowBm;*)  PROCEDURE ShowBm(bmd: BitmapDescriptor);    VAR DDBMD: DisplayDriver.BMDescriptor;  BEGIN    DDBMD := DisplayDriver.BMDescriptor(bmd);    DisplayDriver.Show(DDBMD, TRUE);  END ShowBm;   (****************************************************)  (* verifying position and font                      *)  (****************************************************)  PROCEDURE FontDefaults(fa: CARDINAL); (*exported*)    (*installs the Font prepared in fa as default*)    PROCEDURE CheckPosition;      (*install the default values of absLine*)    BEGIN       absLine.h := charH + charH DIV 10 + 1;      IF (absLine.x<absWindow.x)          OR ((absLine.x-absWindow.x)>absWindow.w)          OR (absLine.y<absWindow.y)          OR ((absLine.y-absWindow.y+absLine.h)>absWindow.h) THEN           absLine.x := absWindow.x;            absLine.y := absWindow.y+absWindow.h-absLine.h      END;      absLine.w := absWindow.x+absWindow.w-absLine.x;    END CheckPosition;  BEGIN    fontHint := fa;    charH := LXFW(fa-1, 2) MOD 256;    charWmax := LXFW(fa-1, 3);    IF INTEGER(charWmax)>0 THEN charWmin := charWmax              (*not proportional*)    ELSE charWmin := 1; charWmax := CARDINAL(-INTEGER(charWmax))  (*proportional*)    END;    CheckPosition;  END FontDefaults;  (****************************************************)  (* driving for Screen, TextScreen, WindowHandler    *)  (****************************************************)  VAR defaultSetLevel: CARDINAL;      saveDefaultSetLevel: CARDINAL;      saveDefaultsRec: DefaultsRecord;       procLevel: CARDINAL;      saveProcLevel: CARDINAL;      saveProcRec: TextProcRecord;   PROCEDURE SetProcRec(VAR r: TextProcRecord);    VAR done: BOOLEAN;  BEGIN     IF saveProcLevel<>0 THEN HALT END;    saveProcRec := actualProcRec;    saveProcLevel := procLevel;    procLevel := CurrentLevel();    actualProcRec := r;    AssignWrite(WriteProcedure(r.write), done)      (*sorry about type conversion; wanted to use the definition        before availability of module TerminalBase*)  END SetProcRec;  PROCEDURE SetDefaultRec(VAR r: DefaultsRecord);  BEGIN     IF saveDefaultSetLevel<>0 THEN HALT END;    saveDefaultsRec := actualDefaultsRec;    saveDefaultSetLevel := defaultSetLevel;    defaultSetLevel := CurrentLevel();    actualDefaultsRec := r;  END SetDefaultRec;  (****************************************************)  (* level return                                     *)  (****************************************************)  PROCEDURE LevelReturn;    PROCEDURE PositionInside(): BOOLEAN;    BEGIN       RETURN        (absLine.x<=maxWidth)          AND (absLine.w<=maxWidth)         AND (absLine.x+absLine.w<=maxWidth)         AND (absLine.y<=maxHeight)    END PositionInside;  BEGIN     b := TRUE;    InitSys;    WHILE defaultSetLevel>=CurrentLevel() DO      actualDefaultsRec := saveDefaultsRec;      defaultSetLevel := saveDefaultSetLevel;      saveDefaultSetLevel := 0;    END;    WHILE procLevel>=CurrentLevel() DO      actualProcRec := saveProcRec;      procLevel := saveProcLevel;      saveProcLevel := 0;       b := FALSE;    END;    IF initatlevel>=CurrentLevel() THEN (*for nonresident module only once*)      WITH absWindow DO         x := 0; y := 0; w := maxWidth; h := maxHeight  (*without dirty half lines*)      END;       bitmapHint := ADR(sysBMD);      b := PositionInside() AND b;      FontDefaults(sysF);      IF NOT b THEN WriteChar(14C) END;    END;    ShowBm(sysBMD);  END LevelReturn;  (****************************************************)  (* Output procedures                                *)  (****************************************************)  CONST    BS  =  10C;    LF  =  12C;    FF  =  14C;    CR  =  15C;    DEL = 177C;    EOL =  36C;  PROCEDURE CarriageReturn;   BEGIN     absLine.x := absWindow.x;    absLine.w := absWindow.w;   END CarriageReturn;  PROCEDURE LineFeed;      PROCEDURE ScrollUp;       VAR source, dest: BlockDescriptor;    BEGIN      source := absWindow;      DEC(source.h, absLine.h);        dest := source;      INC(dest.y, absLine.h);       BBLT(replace, bitmapHint, source, dest, bitmapHint);      source.h := absLine.h;      REPL(replace, bitmapHint, ADR(white), source);    END ScrollUp;  BEGIN     IF absLine.h <= absLine.y - absWindow.y THEN       DEC(absLine.y, absLine.h);      RETURN     ELSE ScrollUp;    END;   END LineFeed;  PROCEDURE Writeln;   BEGIN     CarriageReturn;    LineFeed;   END Writeln;  PROCEDURE ClearChars(n: CARDINAL); (*exported*)    VAR blk: BlockDescriptor;  BEGIN    blk := absLine;    IF absLine.w DIV charWmax >= n THEN blk.w:= n*charWmax END;    REPL(replace, bitmapHint, ADR(white), blk);  END ClearChars;  PROCEDURE WriteChar(ch: CHAR); (*exported*)  BEGIN     IF (ch<=37C) OR (ch>=DEL) THEN      IF    ch = EOL THEN Writeln;      ELSIF ch = CR  THEN CarriageReturn;       ELSIF ch = LF  THEN LineFeed;       ELSIF (ch = DEL) OR (ch = BS) THEN        IF absLine.x - absWindow.x > charWmin THEN          DEC(absLine.x, charWmin);          INC(absLine.w, charWmin)        ELSE CarriageReturn        END;        IF ch = DEL THEN ClearChars(1) END;      ELSIF ch = FF THEN        REPL(replace, bitmapHint, ADR(white), absWindow);        absLine.x := absWindow.x;        absLine.w := absWindow.x + absWindow.w - absLine.x;        absLine.y := absWindow.y + absWindow.h - absLine.h;      END;      RETURN    END;    IF (absLine.w<charWmax) THEN Writeln END;    DCH(bitmapHint, fontHint, absLine, ch);  END WriteChar;  (****************************************************)  (* Machine instructions                             *)  (****************************************************)    PROCEDURE LXFW(frame, offset: WORD): CARDINAL;    CODE 203B    END LXFW;    PROCEDURE DCH(bma: WORD; font: WORD; VAR line: BlockDescriptor; ch: CHAR);    CODE 345B    END DCH;     PROCEDURE REPL(m: Mode; bm: WORD; patAddr: WORD; VAR dest: BlockDescriptor);    CODE 343B    END REPL;    PROCEDURE BBLT(m: Mode; dbma: WORD; VAR s,d: BlockDescriptor; sbma: WORD );    CODE 344B    END BBLT;    PROCEDURE ROR(x,n: CARDINAL): CARDINAL;    CODE 275B    END ROR;(*if resident    PROCEDURE PUT(channel, value: WORD);    CODE 241B    END PUT;    PROCEDURE GET(channel: WORD; VAR value: WORD);    CODE 240B    END GET;*)BEGIN   defaultSetLevel := 0;  saveDefaultSetLevel := 0;  procLevel := 0;   saveProcLevel := 0;  actualProcRec.windowHandler := FALSE;  absLine.x := 177777B; (*bad position; leads to reeinitialization *)  WITH white DO     leng := 1;  pat := 0   END;  CheckDisplay;  IF lockBitmap THEN    Frames.Allocate(BMA, maxWidth DIV 16 * maxHeight);                     (* firmware error: replicate not on high memory address                       is fixed by frame allocater: uses that memory last*)  ELSE     DisplayDriver.Write(14C);    BMA := ROR(DisplayDriver.BMD.f, 2);  END;  initatlevel := CurrentLevel() (** if resident: +1 *) ;  LevelReturn;  AssignWrite(WriteChar, b);   TermProcedure(LevelReturn);END ScreenDriver2.