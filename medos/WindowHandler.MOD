(*********************************                               * *    WindowHandler              **    *************              **                               **    Christian Jacobi           * *    Institut fuer Informatik   **    ETH-Zuerich                **    CH-8092 Zuerich            **                               *********************************) (* Version 4 for Medos V4  20.12.81 *)(* Version 5 for Medos V4  20.10.82 allows modifying overlaid window *)IMPLEMENTATION MODULE WindowHandler;    FROM SYSTEM IMPORT    ADDRESS, WORD, ADR;  FROM Screen IMPORT    GetDefaultBitmap, GetDefaultFont, GetMaxBlock,     SetDefaultBitmap, SetDefaultFont,    GetSystemBitmap, GetSystemFont,    ShowBitmap, GetFontName,    (*DisplayChar, Replicate, BlockTransfer, DisplayDot, *)      replace, invert,    CreateSubBitmap, CreateBitmap, ReturnBitmap,    (*LoadFont,*) FontHeight, FontWidth, CharWidth, Proportional, FontBaseLine;  FROM Terminal IMPORT    Write, WriteString, WriteLn, Read;  FROM Monitor IMPORT     CurrentLevel, SharedLevel, TermProcedure;  IMPORT           Screen, FileSystem, ScreenDriver2;  (*********conditionals for compiling*)  CONST    debug   = TRUE;          (* debug the client module *)    debugMe = FALSE;         (* debug the windowhandler *)    drawbelow = TRUE;        (* NOT (window PutOnTop before any action) *)    terminalputontop = FALSE;(* Terminal.Write calls PutOnTop *)    (*$T-*)    (*$R-*)  (*********end conditionals*)  MODULE Strings;    EXPORT AssignString, EqualString;    PROCEDURE AssignString(VAR res: ARRAY OF CHAR; source: ARRAY OF CHAR);      VAR i: CARDINAL;    BEGIN      i  := 0;      WHILE (i<=HIGH(res)) AND (i<=HIGH(source)) AND (source[i]<>0C) DO        res[i] := source[i];        INC(i)       END;      IF i<=HIGH(res) THEN        res[i] := 0C;      END;    END AssignString;    PROCEDURE EqualString(VAR s1: ARRAY OF CHAR;                              s2: ARRAY OF CHAR): BOOLEAN;      VAR i: CARDINAL;    BEGIN      i := 0;      LOOP        IF i>HIGH(s1) THEN           RETURN (i>HIGH(s2)) OR (s2[i]=0C)        END;        IF i>HIGH(s2) THEN           RETURN (s1[i]=0C)        END;        IF s1[i]<>s2[i] THEN RETURN FALSE END;        IF s1[i]=0C THEN RETURN TRUE END;        INC(i)      END    END EqualString;  END Strings;  MODULE Blocks;    IMPORT BlockDescriptor, ADR;    EXPORT       BlockProcedure,      Inside, Overlay, InsidePoint,      HandleDifference;    (* a BlockDescriptor is called legal if       x+w <= 177777B and y+h <= 177777;       it then does not lead to overflow;        most blocks are not assumed to be "legal";       if legality is required this is documented *)              TYPE BlockProcedure = PROCEDURE(BlockDescriptor);    PROCEDURE Inside(VAR b1, b2: BlockDescriptor): BOOLEAN;      (* Inside := b1 <= b2; assume b1 does not lead to overflow *)    BEGIN      RETURN (b1.x >= b2.x) AND (b1.y >= b2.y)           AND (b1.x-b2.x +(*may ovl*) b1.w <=  b2.w)           AND (b1.y-b2.y +(*may ovl*) b1.h <=  b2.h)     END Inside;     PROCEDURE Overlay(VAR b1, b2: BlockDescriptor): BOOLEAN;      (* returns blocks b1 and b2 have some common space *)    BEGIN      IF b1.x<b2.x THEN         IF b1.w <= b2.x-b1.x THEN RETURN FALSE END;      ELSE        IF b2.w <= b1.x-b2.x THEN RETURN FALSE END;      END;        IF b1.y<b2.y THEN RETURN b1.h > b2.y-b1.y END;      RETURN b2.h > b1.y-b2.y;     END Overlay;    PROCEDURE InsidePoint(b: BlockDescriptor; x, y: CARDINAL): BOOLEAN;      (* returns point (x,y) is inside of block b *)    BEGIN      RETURN (x >= b.x) AND (x-b.x < b.w)           AND (y >= b.y) AND (y-b.y < b.h)    END InsidePoint;    PROCEDURE HandleDifference(a, b: BlockDescriptor;                 handler: BlockProcedure);      (* handles the area a-b by the procedure handler *)      VAR t: BlockDescriptor;    BEGIN (* (w>h) is more efficient then (h>w) in microcode *)         IF Overlay(b, a) THEN               IF b.y+b.h<a.y+a.h THEN  (* handle upper part of a *)          t.x := a.x; t.w := a.w;          t.y := b.y+b.h; t.h := a.y+a.h-t.y;          handler(t);          DEC(a.h, t.h);         END;        IF b.y>a.y THEN          (* handle lower part of a*)          t.x := a.x; t.w := a.w;          t.y := a.y; t.h := b.y-a.y;          handler(t);          INC(a.y, t.h); DEC(a.h, t.h);         END;        IF b.x+b.w<a.x+a.w THEN  (* handle right part of a *)          t.x := b.x+b.w; t.w := a.x+a.w-t.x;          t.y := a.y; t.h := a.h;          handler(t);           DEC(a.w, t.w);         END;        IF b.x>a.x THEN          (* handle left part of a*)          t.x := a.x; t.w := b.x-a.x;          t.y := a.y; t.h := a.h;          handler(t);        END;      ELSE        handler(a)      END    END HandleDifference;  END Blocks;  MODULE FontHandler;    FROM Screen IMPORT Font, LoadFont, GetSystemFont, GetFontName;    IMPORT EqualString, CurrentLevel, SharedLevel;     EXPORT GiveFont, FontLevelReturn;        CONST highf = 15;    VAR fontArray: ARRAY [0..highf] OF          RECORD            font: Font;            fLev: CARDINAL;          END;        fontHead: CARDINAL;    PROCEDURE FontLevelReturn;    BEGIN      WHILE fontArray[fontHead].fLev>CurrentLevel() DO         DEC(fontHead)      END    END FontLevelReturn;    PROCEDURE GiveFont(VAR f: Font; fname: ARRAY OF CHAR;                 VAR done: BOOLEAN);      (*loads font only if necessary*)      VAR        n: CARDINAL;        lName: ARRAY [0..24] OF CHAR;      BEGIN done := FALSE;      n := fontHead;      LOOP        GetFontName(lName, fontArray[n].font);        IF EqualString(lName, fname) THEN (*font already loaded*)          f := fontArray[n].font; done := TRUE;          EXIT        END;        n := n+1;        IF n>fontHead THEN (*font not loaded now*)          IF n<=highf THEN            LoadFont(f, fname, done);            IF done THEN              WITH fontArray[n] DO                font := f;                fLev := SharedLevel();              END;              fontHead := n;            END;          END;          EXIT        END;      END;    END GiveFont;  BEGIN    fontHead := 0;    WITH fontArray[0] DO      GetSystemFont(font); fLev := 0;     END;  END FontHandler;  VAR    absMaxBlk:  BlockDescriptor;    fullBitmap: Bitmap;  MODULE PaintBlocks;    IMPORT       Screen, BlockDescriptor, Mode, fullBitmap;    EXPORT       Greay, Paint, Erase,      black, white;    TYPE      Pattern6 =         RECORD          nr: CARDINAL;          g:  ARRAY [0 .. 5] OF CARDINAL        END;      Pattern1 =        RECORD          a, b: CARDINAL        END;    VAR      black, white: Pattern1;      greay:        Pattern6;    PROCEDURE Greay(blk: BlockDescriptor);      (*blk in absolute coordinates*)      PROCEDURE ROR(val, count: CARDINAL): CARDINAL;        (* ROR instruction; used to rotate a pattern right*)        CODE 275B      END ROR;      VAR         tmpGreay: Pattern6;        i, j, c, l: CARDINAL;    BEGIN      l := greay.nr;      c := 16 - blk.x MOD 16; (*MOD 16 again made by firmware*)      i := l - ((blk.y + blk.h) MOD l);      tmpGreay.nr := l;      FOR j := 0 TO l-1 DO        tmpGreay.g[j] :=  ROR(greay.g[(i+j) MOD l], c);      END;      Screen.Replicate(fullBitmap, blk, replace, tmpGreay)    END Greay;    PROCEDURE Erase(blk: BlockDescriptor);      (*blk in absolute coordinates*)    BEGIN      Screen.Replicate(fullBitmap, blk, replace, white)    END Erase;    PROCEDURE Paint(blk: BlockDescriptor);      (*blk in absolute coordinates*)    BEGIN      Screen.Replicate(fullBitmap, blk, replace, black)    END Paint;  BEGIN (*PaintBlocks*)    WITH black DO      a  := 1;      b  := 177777B    END;    WITH white DO      a  := 1;      b  := 0    END;    WITH greay DO      nr := 6;      g[0] := 8 * 1111H;      g[1] := 0;      g[2] := 0;      g[3] := 2 * 1111H;      g[4] := 0;      g[5] := 0    END;  END PaintBlocks;  CONST    BS  =  10C;    LF  =  12C;    FF  =  14C;    CR  =  15C;    DEL = 177C;    EOL =  36C;     TYPE    WindowHint    = POINTER TO WindowAttributes;    OverlayingInfo =      RECORD        saved:        BOOLEAN; (*if saved: Restore is needed before operation;                                 else window is completely visible*)        saveBmAlloc:  BOOLEAN;        saveBmFather: Bitmap;        saveBm:       Bitmap;        saveBmLev:    CARDINAL; (*is sharedlevel*)      END;         WindowAttributes =      RECORD        dbitmap:       Bitmap;         dfont:         Font;           savedEol:      BOOLEAN;         (*invariant: IF savedEol THEN rLine.w=0 *)        innerBlock:    BlockDescriptor; (*absolute coordinates, bitmap of window*)        outerBlock:    BlockDescriptor; (*absolute coordinates, incl. border*)               rLine:         BlockDescriptor; (*current relative position*)        charWmin, charWmax, charH: CARDINAL;        normalWindow:  BOOLEAN; (*if FALSE then not in users window-queue*)        nextDown:      WindowHint;        nextUp:        WindowHint;        originalWindow: Window;        ovi:           OverlayingInfo;        cLevel:        CARDINAL;        sLevel:        CARDINAL;        signal:        WindowProc;        autorestore:   BOOLEAN;       END;  CONST defaultstackTopMax = 6;  VAR    defaultWindow:  Window;    fullScreen:     Window;  (* the fullScreen window is also used as                                 dummy in the double linked circular list                                of windows *)     fullScreenHint: WindowHint;      defaultstackTop: CARDINAL;    defaultstack:    ARRAY [0..defaultstackTopMax] OF                        RECORD dlevel: CARDINAL; dwin: Window END;                       (*usage of defaultstack, defaultstackTop:                          but only after UseForDefault was called                          defaultstack[defaultstackTop].dlevel -> is current level                          defaultstack[defaultstackTop].dwin   -> default of current level                       *)    onReturnFlag:    BOOLEAN;    onChangingWindow: Window;    onClosingWindow:  Window;    headerHeight:    CARDINAL;    defaultFont:     Font;    headerFont:      Font;    criticalLevel:   CARDINAL;   MODULE WindowStorage;    IMPORT       Window, WindowDescriptor, WindowAttributes,       CurrentLevel, ADDRESS, ADR;    EXPORT NewWindow, DisposeWindow, MemLevReturn;    (* takes care about storage with levels       users don't know WindowMemory    *)    TYPE      WindowMemory =         RECORD          pub: WindowDescriptor;          prv: WindowAttributes        END;    CONST max = 20;         VAR memory: ARRAY[0..max] OF WindowMemory;         n: CARDINAL;    PROCEDURE NewWindow(VAR w: Window; VAR done: BOOLEAN);      (* and initializes the wptr field *)      VAR n: CARDINAL;    BEGIN      n := 0;      WHILE (memory[n].prv.cLevel<>177777B) AND (n<=max) DO INC(n) END;      done := n<=max;      IF done THEN        memory[n].prv.cLevel := CurrentLevel();        w := ADDRESS(ADR(memory[n].pub));        w^.wptr := ADDRESS(ADR(memory[n].prv));      END    END NewWindow;    PROCEDURE DisposeWindow(VAR w: Window);    BEGIN      w^.wptr^.cLevel := 177777B;      w^.wptr := NIL;      w := NIL;    END DisposeWindow;    PROCEDURE MemLevReturn;    BEGIN      FOR n := 0 TO max DO         IF memory[n].prv.cLevel>=CurrentLevel() THEN           memory[n].prv.cLevel := 177777B         END      END    END MemLevReturn;  BEGIN    FOR n := 0 TO max DO memory[n].prv.cLevel := 177777B END  END WindowStorage;  MODULE PartialVisible;    IMPORT BlockDescriptor, WindowHint,            fullScreenHint,            Overlay, HandleDifference, Greay,           Screen, replace, Window, drawbelow, debugMe;    EXPORT DrawBackGround, VisibleTransfer, RepaintVisible;    VAR       diffDown: WindowHint; (*current state of recursion*)      xw: WindowHint;       (*gets special treatment:                                  ignored in DrawBackGround;                                 the window for VisibleTransfer *)      PROCEDURE PaintGreyDown(b: BlockDescriptor);      VAR d: WindowHint; blk: BlockDescriptor;    BEGIN      d := diffDown;      IF (b.w>0) AND (b.h>0) THEN        WHILE (diffDown<>fullScreenHint) AND           (NOT Overlay(diffDown^.outerBlock, b) OR (diffDown=xw)) DO           diffDown := diffDown^.nextDown        END;        IF diffDown=fullScreenHint THEN Greay(b)        ELSE           blk := diffDown^.outerBlock;          diffDown := diffDown^.nextDown;          HandleDifference(b, blk, PaintGreyDown);        END      END;      diffDown := d    END PaintGreyDown;    PROCEDURE DrawBackGround(b: BlockDescriptor; ignore: WindowHint);    BEGIN      diffDown := fullScreenHint^.nextDown;      xw := ignore;      PaintGreyDown(b)    END DrawBackGround;    PROCEDURE VisibleTransferDown(b: BlockDescriptor);      VAR d: WindowHint; blk: BlockDescriptor;    BEGIN      IF drawbelow THEN        d := diffDown;        IF (b.w>0) AND (b.h>0) THEN          WHILE (diffDown<>xw) AND             NOT Overlay(diffDown^.outerBlock, b) DO             diffDown := diffDown^.nextDown          END;          IF diffDown=xw THEN             WITH xw^ DO              DEC(b.x, innerBlock.x);              DEC(b.y, innerBlock.y);              Screen.BlockTransfer(dbitmap, b, replace, ovi.saveBm, b)            END          ELSE             blk := diffDown^.outerBlock;            diffDown := diffDown^.nextDown;            HandleDifference(b, blk, VisibleTransferDown);          END        END;        diffDown := d      END    END VisibleTransferDown;    PROCEDURE VisibleTransfer(w: Window; b: BlockDescriptor);       (* b is relative to w *)    BEGIN      IF debugMe THEN         IF drawbelow THEN          IF NOT w^.wptr^.ovi.saved THEN HALT END;        ELSE HALT END      END;      IF drawbelow THEN        diffDown := fullScreenHint^.nextDown;        xw := w^.wptr; (*Window to update*)        WITH xw^ DO          INC(b.x, innerBlock.x);          INC(b.y, innerBlock.y);        END;        VisibleTransferDown(b)      END    END VisibleTransfer;    PROCEDURE RepaintVisible(w: Window);     BEGIN      IF debugMe THEN         IF drawbelow THEN          IF NOT w^.wptr^.ovi.saved THEN HALT END;        ELSE HALT END      END;      IF drawbelow THEN        diffDown := fullScreenHint^.nextDown;        xw := w^.wptr; (*Window to update*)        VisibleTransferDown(xw^.innerBlock)      END    END RepaintVisible;  END PartialVisible;(*debugging tool  PROCEDURE InfoWindow(w: Window);    VAR b: BlockDescriptor;  BEGIN    IF w=NIL THEN WriteString("NIL window"); WriteLn;    ELSE      WriteString(w^.header); Write(" ");  WriteO(w, 6); WriteLn;      IF w^.wptr=NIL THEN WriteString(" wptr = NIL"); WriteLn;      ELSE        WriteString(" wptr = "); WriteO(w^.wptr, 6); WriteLn;        IF w^.wptr^.originalWindow<>w THEN          WriteString(" ** error originalWindow = ");           WriteO(w^.wptr^.originalWindow, 6); WriteLn;        END;        WriteString(" bitmap = "); WriteC(CARDINAL(w^.wptr^.dbitmap), 0);        GetMaxBlock(b, w^.wptr^.dbitmap);        WriteString(" w = "); WriteO(b.w, 4);        WriteString(" h = "); WriteO(b.h, 4); WriteLn;      END    END;  END InfoWindow;*)  PROCEDURE NotConsistency(w: Window): BOOLEAN;    VAR b1, b2: BlockDescriptor;  BEGIN    IF (w=NIL) OR (w^.wptr=NIL) OR (w^.wptr^.originalWindow<>w) THEN      IF onReturnFlag THEN (* no messages or halts in a termprocedure*)        IF NOT debugMe THEN RETURN TRUE END;      END;      IF (w=defaultWindow) OR (w=FullScreen()) THEN (*schlimm, schlimm*)        IF w<>FullScreen() THEN           UseForDefault(FullScreen()); WriteString("- in default");        ELSE HALT        END      END;       WriteLn; WriteString("- WindowHandler: consistency"); WriteLn;      IF debugMe THEN         IF w=NIL THEN WriteString(" NIL window")          ELSIF w^.wptr=NIL THEN WriteString(" NIL wptr")          ELSE WriteString("wptr^.originalWindow error")        END;        HALT       ELSE RETURN TRUE       END    ELSIF debugMe AND (w<>onClosingWindow) THEN      WITH w^.wptr^ DO        GetMaxBlock(b1, w^.bm);        IF (b1.w=0) OR (b1.h=0) THEN          WriteString("- WindowHandler: block empty"); WriteLn; HALT        END;        IF CARDINAL(dbitmap)<>CARDINAL(w^.bm) THEN          GetMaxBlock(b2, dbitmap);          IF (b1.w<>b2.w) OR (b1.h<>b2.h) THEN            IF (w=defaultWindow) THEN w^.bm := dbitmap;               WriteString("- in default");            END;            WriteString("- WindowHandler: block error"); WriteLn; HALT           END        END;      END;    END;    IF debugMe THEN      IF (w^.wptr^.nextDown^.nextUp<>w^.wptr)         OR (w^.wptr^.nextUp^.nextDown<>w^.wptr) THEN        WriteString("- chain error"); HALT;       END;    END;    RETURN FALSE  END NotConsistency;  PROCEDURE ConsistencyCheck(w: Window);  BEGIN    IF NotConsistency(w) THEN HALT END  END ConsistencyCheck;  PROCEDURE CheckList();    VAR winPtr: WindowHint;  BEGIN    winPtr := fullScreenHint^.nextDown;    WHILE winPtr<>fullScreenHint DO      ConsistencyCheck(winPtr^.originalWindow);      winPtr := winPtr^.nextDown    END;  END CheckList;  PROCEDURE SetUserFields(w: Window);  BEGIN    WITH w^ DO      WITH wptr^ DO        IF ovi.saved AND autorestore THEN bm := ovi.saveBm;         ELSE bm := dbitmap;         END;        font := dfont;        outerblk := outerBlock;        innerblk := innerBlock;        overlaid := ovi.saved;      END    END  END SetUserFields;  PROCEDURE WriteTitle(w: Window);    (* paint title and border; uses innerBlock, outerBlock *)    VAR       blk, line: BlockDescriptor;      ch: CHAR;      i: CARDINAL;  BEGIN    WITH w^.wptr^ DO      (*clear title field*)      blk := outerBlock;      blk.y := innerBlock.y + innerBlock.h;      blk.h := outerBlock.y + outerBlock.h-blk.y;      IF blk.h>0 THEN        Erase(blk);        IF blk.h>FontHeight(headerFont) THEN          (*write the title*)          i  := 0;          line.x := blk.x+2; line.w := blk.w-3;           line.y := blk.y+1; line.h := blk.h-1;          LOOP            IF (i > HIGH(originalWindow^.header)) THEN EXIT END;            ch := originalWindow^.header[i];            IF ch = 0C THEN EXIT END;            IF line.w < CharWidth(dfont, ch) THEN EXIT END;            Screen.DisplayChar(fullBitmap, line, headerFont, ch);            INC(i)          END;        END;        (*invert the field*)        Screen.Replicate(fullBitmap, blk, invert, black);        (*paint the border*)        line := outerBlock; DEC(line.h, blk.h);        HandleDifference(line, innerBlock, Paint)       END    END;  END WriteTitle;  PROCEDURE InitFontData(VAR wa: WindowAttributes);  BEGIN      WITH wa DO      charH := FontHeight(dfont);      charWmax := FontWidth(dfont);      IF Proportional(dfont) THEN         charWmin := 1       ELSE         charWmin := charWmax      END;    END  END InitFontData;    MODULE Monitor[15];    IMPORT WindowHint, fullScreenHint;    EXPORT TakeOutOfList, MoveOnTopOfList, IncludeOnTop;    PROCEDURE TakeOutOfList(x: WindowHint);    BEGIN      WITH x^ DO        nextUp^.nextDown := nextDown;        nextDown^.nextUp := nextUp;      END    END TakeOutOfList;    PROCEDURE IncludeOnTop(x: WindowHint);    BEGIN      WITH x^ DO        nextUp := fullScreenHint;        nextDown := fullScreenHint^.nextDown;      END;      WITH fullScreenHint^ DO        nextDown^.nextUp := x;        nextDown := x;      END    END IncludeOnTop;    PROCEDURE MoveOnTopOfList(x: WindowHint);    BEGIN      TakeOutOfList(x);      IncludeOnTop(x)    END MoveOnTopOfList;   END Monitor;  PROCEDURE SaveAreaAvailable(w: Window; newW, newH: CARDINAL): BOOLEAN;                                       (*does not change the window list*)    VAR       done: BOOLEAN;       temB: BlockDescriptor;   BEGIN    WITH w^.wptr^ DO      IF ovi.saveBmAlloc OR NOT autorestore THEN RETURN TRUE       ELSE        (*creation of save area*)        CreateBitmap(ovi.saveBmFather, newW, newH, done);        IF NOT done THEN RETURN FALSE END;        temB.w := newW; temB.h := newH; temB.x := 0; temB.y := 0;        CreateSubBitmap(ovi.saveBm, ovi.saveBmFather, temB, done);        IF NOT done THEN            ReturnBitmap(ovi.saveBmFather);          RETURN FALSE        END;        ovi.saveBmLev := SharedLevel();        ovi.saveBmAlloc := TRUE;        RETURN TRUE;      END;    END;  END SaveAreaAvailable;  PROCEDURE SaveWindow(w: Window): BOOLEAN;                                       (*does not change the window list*)    VAR       temB: BlockDescriptor;      done: BOOLEAN;  BEGIN    IF debugMe THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      IF ovi.saved THEN RETURN TRUE END;      (*if not saved, window is completely visible*)      IF autorestore THEN         temB := innerBlock; temB.x := 0; temB.y := 0;        IF NOT ovi.saveBmAlloc THEN           IF NOT SaveAreaAvailable(w, temB.w, temB.h) THEN RETURN FALSE END;        END;        (*actual saving*)        Screen.BlockTransfer(ovi.saveBmFather, temB, replace,                             fullBitmap, innerBlock);        w^.bm := ovi.saveBm;      END;      signal(w, save);      ovi.saved := TRUE; w^.overlaid := TRUE;      RETURN TRUE    END  END SaveWindow;  PROCEDURE RestoreWindow(w: Window);    (*puts window visible;      if window is not allready visible, it take w out of the      list and puts it on top of the windowlist;      does not change the part of the list below w !       (important for RestoreAllUnder: which loops through the list)    *)   VAR       temB: BlockDescriptor;      winPtr: WindowHint;  BEGIN    IF debugMe THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      IF ovi.saved THEN         SaveAllOver(w);        WriteTitle(w);        MoveOnTopOfList(w^.wptr);        ovi.saved := FALSE; w^.overlaid := FALSE;        IF autorestore THEN          temB := innerBlock; temB.x := 0; temB.y := 0;          Screen.BlockTransfer(fullBitmap, innerBlock, replace,                               ovi.saveBmFather, temB);          w^.bm := dbitmap;        ELSE Clear(w)        END;        signal(w, redraw)      END;    END  END RestoreWindow;  PROCEDURE RestoreAllUnder(b: BlockDescriptor; except: Window);                                        (*modifies the window list*)    VAR winPtr, nxt: WindowHint;  BEGIN    winPtr := fullScreenHint^.nextDown;    WHILE winPtr <> fullScreenHint DO      nxt := winPtr^.nextDown;      IF Overlay(b, winPtr^.outerBlock)             AND (except<>winPtr^.originalWindow) THEN         IF NOT onReturnFlag OR (winPtr^.cLevel<CurrentLevel()) THEN           RestoreWindow(winPtr^.originalWindow)               (* dont modify lower part of list *)        END      END;      winPtr := nxt    END;  END RestoreAllUnder;  PROCEDURE SaveAllOver(w: Window);  (*does not modify the window list*)    VAR      winPtr: WindowHint;      done: BOOLEAN;  BEGIN    (*no consistency check; since bitmaps of w can be returned allready*)    winPtr := w^.wptr^.nextUp;    WHILE winPtr <> fullScreenHint DO      IF Overlay(w^.wptr^.outerBlock, winPtr^.outerBlock) THEN         done := SaveWindow(winPtr^.originalWindow)      END;      winPtr := winPtr^.nextUp    END;  END SaveAllOver;  PROCEDURE CreateWindow(VAR w: Window;              right, up, width, height: CARDINAL;              name: ARRAY OF CHAR;              savecontents: BOOLEAN;              handler: WindowProc;              VAR done: BOOLEAN);    PROCEDURE GiveInner(VAR inBlk: BlockDescriptor;                borderBlk: BlockDescriptor; headerH: CARDINAL);      (*compute the inner block starting from a borderblock*)      CONST borderThick = 1;    BEGIN      inBlk.x := borderBlk.x+borderThick;      inBlk.y := borderBlk.y+borderThick;      inBlk.w := borderBlk.w-2*borderThick;      inBlk.h := borderBlk.h-2*borderThick-headerH;    END GiveInner;    VAR localW: Window;        b: BlockDescriptor;        lWd: WindowHint;        i: CARDINAL;         bb, overlay: BOOLEAN;  BEGIN    IF debugMe THEN CheckList END;    done := FALSE; w := NIL; overlay := FALSE;    WITH b DO      x := right;      y := up;      h := height;      w := width    END;    IF (width<16) OR (height<40) THEN RETURN END;    IF NOT Inside(b, absMaxBlk) THEN       b.x := 0; b.y := 0;       IF NOT Inside(b, absMaxBlk) THEN RETURN END    END;    lWd := fullScreenHint^.nextDown;    WHILE lWd <> fullScreenHint DO      IF Overlay(b, lWd^.outerBlock) THEN        IF NOT SaveWindow(lWd^.originalWindow) THEN RETURN END;        overlay := TRUE;      END;      lWd := lWd^.nextDown    END;    NewWindow(localW, bb);     IF NOT bb THEN RETURN END;    WITH localW^ DO      (*NEW(wptr);*)       WITH wptr^ DO        ovi.saved := FALSE; ovi.saveBmAlloc := FALSE;        outerBlock := b;        normalWindow := TRUE;        signal := handler; autorestore := savecontents;        GiveInner(innerBlock, outerBlock, headerHeight*ORD(name[0]<>0C));        IF overlay AND NOT           SaveAreaAvailable(localW, innerBlock.w, innerBlock.h) THEN          RETURN        END;        CreateSubBitmap(dbitmap, fullBitmap, innerBlock, done);        IF NOT done THEN RETURN END;        dfont := defaultFont; InitFontData(wptr^);        AssignString(header, name);        originalWindow := localW;        sLevel := SharedLevel(); cLevel := CurrentLevel();        resSystem := NIL; resOwner := NIL;        IncludeOnTop(wptr);        SetUserFields(localW);        WriteTitle(localW);        Clear(localW); (*initializes rLine *)        IF defaultWindow=fullScreen THEN          UseForDefault(localW);          DrawBackGround(absMaxBlk, NIL);        END;        w := localW;        signal(w, opened);      END    END;    IF debugMe THEN CheckList END;  END CreateWindow;  PROCEDURE IgnoreWindowSignal(w: Window; s: WindowSignal);  BEGIN   END IgnoreWindowSignal;  PROCEDURE OpenWindow(VAR w: Window; right, up, width, height: CARDINAL;                        name: ARRAY OF CHAR; VAR done: BOOLEAN);  BEGIN     CreateWindow(w, right, up, width, height, name, TRUE,       IgnoreWindowSignal, done);  END OpenWindow;  PROCEDURE CloseWindow(VAR w: Window);    VAR      winPtr: WindowHint;      myWindow: Window;      backg: BOOLEAN;     BEGIN backg := TRUE;   IF debugMe THEN CheckList END;   myWindow := w; (*if any handler would cause assignments*)   (*windows may be errounous closed several times;     CloseWindow is not allowed to call HALT; because of calls      on a level return *)    IF NotConsistency(myWindow) OR (myWindow^.wptr^.sLevel<SharedLevel()) THEN RETURN END;    IF myWindow = fullScreen THEN      (*stops windowhandling if from bottom overlay layer*)      IF defaultstack[0].dlevel = CurrentLevel()-1 THEN        UseForDefault(fullScreen); Write(14C);      END;      RETURN (*avoids dispose*)    END;    IF (myWindow=defaultWindow) THEN       winPtr := fullScreenHint^.nextDown;      IF winPtr^.nextDown=fullScreenHint THEN (*the last window*)        UseForDefault(fullScreen); Write(14C); backg := FALSE;      ELSE        LOOP          IF winPtr=fullScreenHint THEN             UseForDefault(defaultstack[defaultstackTop-1].dwin); EXIT          END;          IF (winPtr^.sLevel=SharedLevel()) AND (myWindow^.wptr<>winPtr) THEN            UseForDefault(winPtr^.originalWindow); EXIT          END;          winPtr := winPtr^.nextDown        END;        WriteString("- closed the default window"); WriteLn;       END    END;    WITH myWindow^.wptr^ DO      IF normalWindow THEN        IF NOT onReturnFlag THEN signal(myWindow, closed) END;        IF NOT onReturnFlag AND backg THEN DrawBackGround(outerBlock, myWindow^.wptr) END;        onClosingWindow := myWindow; (* repeated on CTRL-C*)          ReturnBitmap(dbitmap);          IF ovi.saveBmAlloc THEN ReturnBitmap(ovi.saveBmFather) END;          ovi.saved := TRUE; (*avoid saveing if restore tryes;                               still in list for consistency on CTRL-C*)          RestoreAllUnder(outerBlock, myWindow);          TakeOutOfList(myWindow^.wptr); (* <-critical: exactly once; see level return *)        onClosingWindow := NIL;                END;    END;    IF w=myWindow THEN w := NIL END;    (*DISPOSE(myWindow^.wptr);*)    DisposeWindow(myWindow);    IF debugMe THEN CheckList END;  END CloseWindow;  PROCEDURE ChangeWindow(win: Window; right, up, width, height: CARDINAL;                         VAR done: BOOLEAN);    VAR       winPtr: WindowHint;       overlay: BOOLEAN;       oldSaveBmFather, oldSaveBm: Bitmap;      newBorder, newInside, tem: BlockDescriptor;      lx, ly: CARDINAL;  BEGIN    IF debugMe THEN CheckList END;    done := FALSE; overlay := FALSE;    IF NotConsistency(win) THEN       IF debugMe THEN HALT ELSE RETURN END     END;    WITH win^.wptr^ DO      IF sLevel<SharedLevel() THEN RETURN END;      newBorder.x := right; newBorder.y := up;      newBorder.w := width; newBorder.h := height;      IF normalWindow          AND Inside(newBorder, absMaxBlk)          AND (newBorder.w >= (outerBlock.w-innerBlock.w)+16)          AND (newBorder.h >= (outerBlock.h-innerBlock.h)+16)      THEN        winPtr := fullScreenHint^.nextDown;        WHILE winPtr <> fullScreenHint DO          IF Overlay(newBorder, winPtr^.outerBlock) AND (winPtr<>win^.wptr) THEN             IF NOT SaveWindow(winPtr^.originalWindow) THEN RETURN END;            overlay := TRUE;          END;          winPtr := winPtr^.nextDown        END;        newInside.x := newBorder.x + (innerBlock.x-outerBlock.x);        newInside.y := newBorder.y + (innerBlock.y-outerBlock.y);        newInside.w := newBorder.w - (outerBlock.w-innerBlock.w);        newInside.h := newBorder.h - (outerBlock.h-innerBlock.h);        IF autorestore THEN RestoreWindow(win) ELSE Clear(win) END;        MoveOnTopOfList(win^.wptr);        criticalLevel := cLevel;  (*critical, returns all levels > cLevel on CTRL-C*)        IF overlay THEN           IF ovi.saveBmAlloc THEN            oldSaveBmFather := ovi.saveBmFather;            oldSaveBm := ovi.saveBm;            ovi.saveBmAlloc := FALSE;            IF SaveAreaAvailable(win, newInside.w, newInside.h) THEN              ReturnBitmap(oldSaveBmFather);            ELSE              ovi.saveBmFather := oldSaveBmFather;              ovi.saveBm := oldSaveBm;              ovi.saveBmAlloc := TRUE;              RETURN            END          ELSIF NOT SaveAreaAvailable(win, newInside.w, newInside.h) THEN            RETURN          END;        ELSE          IF ovi.saveBmAlloc THEN            ovi.saveBmAlloc := FALSE;            ReturnBitmap(ovi.saveBmFather);          END;        END;         ReturnBitmap(dbitmap);        CreateSubBitmap(dbitmap, fullBitmap, newInside, done);        IF NOT done THEN HALT (*the bitmap is returned!!*) END;        IF autorestore THEN          (*transfer already initialized contents*)          tem.x := innerBlock.x; tem.y := innerBlock.y;          tem.w := newInside.w;   tem.h := newInside.h;          IF tem.w>innerBlock.w THEN tem.w := innerBlock.w END;          IF tem.h>innerBlock.h THEN tem.h := innerBlock.h END;                  Screen.BlockTransfer(fullBitmap, newInside,                     replace,  fullBitmap, tem);          (*clear new contents*)          tem.x := newInside.x;   tem.y := newInside.y;          HandleDifference(newInside (*complete*), tem (*initialized*), Erase);        ELSE Clear(win)        END;        tem := outerBlock;        outerBlock := newBorder;        innerBlock := newInside;        SetUserFields(win);        WriteTitle(win);        GetDotPos(win, lx, ly);         SetDotPos(win, lx, ly); (*garanties position bitmap*)        done := TRUE;        IF criticalLevel<CurrentLevel() THEN onChangingWindow := win END;         criticalLevel := 177777B; (*no more critical*)          RestoreAllUnder(tem, win); (*on CTRL-C only screen image bad, not data*)          IF NOT onReturnFlag THEN DrawBackGround(tem, NIL) END;          signal(win, changed);        onChangingWindow := NIL;      END    END;   IF debugMe THEN CheckList END;  END ChangeWindow;  PROCEDURE UseForDefault(w: Window);    (*denote w to be used for TextScreen and Terminal output;      w should use a fixed-width font*)  BEGIN    IF debugMe THEN CheckList END;    IF debug THEN ConsistencyCheck(w) END;    (* overlay correction *)      IF (CurrentLevel()>defaultstack[defaultstackTop].dlevel) THEN        IF defaultstackTop>=defaultstackTopMax THEN          WriteString("- WindowHandler: to many levels"); HALT        ELSE          defaultstack[defaultstackTop+1].dlevel := CurrentLevel();          INC(defaultstackTop);        END;      END;      defaultstack[defaultstackTop].dwin := w;    (*this denotes WindowHandler and TextScreen operations*)    IF defaultWindow<>w THEN      defaultWindow^.wptr^.signal(defaultWindow, enddefault);      defaultWindow := w;      defaultWindow^.wptr^.signal(defaultWindow, usedfordefault);    END;    IF debugMe THEN CheckList END;  END UseForDefault;  PROCEDURE PutOnTop(w: Window);  BEGIN    IF debug THEN ConsistencyCheck(w) END;    RestoreWindow(w);  END PutOnTop;  PROCEDURE SetFont(w: Window; VAR f: Font);    (*switch to use the font f*)    VAR b: BlockDescriptor; line, pos: CARDINAL;  BEGIN    IF debug THEN ConsistencyCheck(w) END;    IF debugMe THEN CheckList END;    GetDotPos(w, line, pos);          (*holds position*)    WITH w^.wptr^ DO      IF sLevel<SharedLevel() THEN RETURN END; (*avoid font which can disappear*)      dfont := f;      InitFontData(w^.wptr^);      SetDotPos(w, line, pos);       SetUserFields(w);      signal(w, fontchanged);     END;    IF debugMe THEN CheckList END;  END SetFont;  PROCEDURE LoadFont(w: Window; fname: ARRAY OF CHAR; VAR done: BOOLEAN);    (* Switches to the font specified by fname*)    VAR f: Font;  BEGIN    done := FALSE;    IF NotConsistency(w) THEN       IF debugMe THEN HALT ELSE RETURN END     END;    IF w^.wptr^.sLevel<SharedLevel() THEN RETURN END;    GiveFont(f, fname, done);    IF done THEN SetFont(w, f) END  END LoadFont;    PROCEDURE GetDotPos(w: Window; VAR xx, yy: CARDINAL);    (* gives the current dot position of writing *)  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO       IF savedEol THEN Writeln(w) END;      xx := rLine.x;       yy := rLine.y+FontBaseLine(dfont)    END;  END GetDotPos;  PROCEDURE SetDotPos(w: Window; xx, yy: CARDINAL);     (* sets the current dot position of writing *)    VAR b: BlockDescriptor; bl: CARDINAL;  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO       savedEol := FALSE;      bl := FontBaseLine(dfont);      IF xx > innerBlock.w THEN xx := innerBlock.w END;      IF yy > bl THEN DEC(yy, bl) ELSE yy := 0 END;      IF yy > innerBlock.h THEN yy := innerBlock.h; xx := 0 END;      b.x := xx;      b.y := yy;      b.w :=  innerBlock.w-xx;       b.h := charH + charH DIV 10 + 1;      IF yy+b.h > innerBlock.h THEN b.y := innerBlock.h - b.h END;      rLine := b;            END;  END SetDotPos;  PROCEDURE Replicate(w: Window; VAR dest: BlockDescriptor;                      m: Mode; VAR pattern: ARRAY OF WORD);  BEGIN     IF debug THEN ConsistencyCheck(w) END;    IF w^.overlaid THEN       IF drawbelow AND w^.wptr^.autorestore THEN         Screen.Replicate(w^.bm, dest, m, pattern);        VisibleTransfer(w, dest)      ELSE        RestoreWindow(w); END;        Screen.Replicate(w^.bm, dest, m, pattern);    ELSE Screen.Replicate(w^.bm, dest, m, pattern)    END;  END Replicate;  PROCEDURE BlockTransfer(dw: Window; VAR dest: BlockDescriptor;              m: Mode; sw: Window; VAR source: BlockDescriptor);  BEGIN     (* intentional ERROR: don't care about overlapping blocks       when the windows are not saved pointwise *)      IF debug THEN ConsistencyCheck(dw); ConsistencyCheck(sw)  END;    IF dw^.overlaid AND NOT (drawbelow AND dw^.wptr^.autorestore) THEN      RestoreWindow(dw)     END;    IF drawbelow THEN      IF dw^.overlaid AND NOT dw^.wptr^.autorestore THEN         RestoreWindow(dw)       END    ELSE      IF dw^.overlaid THEN RestoreWindow(dw) END;    END;    IF sw^.overlaid        AND NOT Overlay(dw^.wptr^.outerBlock, sw^.wptr^.outerBlock)       AND NOT sw^.wptr^.autorestore THEN          RestoreWindow(sw)    END;    Screen.BlockTransfer(dw^.bm, dest, m, sw^.bm, source);    IF drawbelow AND dw^.overlaid AND dw^.wptr^.autorestore THEN      VisibleTransfer(dw, dest)    END  END BlockTransfer;  PROCEDURE DisplayDot(w: Window; x, y: CARDINAL; m: Mode);    VAR b: BlockDescriptor;  BEGIN     IF debug THEN ConsistencyCheck(w) END;    IF w^.overlaid THEN       IF drawbelow AND w^.wptr^.autorestore THEN         Screen.DisplayDot(w^.bm, x, y, m);        b.x := x; b.y := y; b.w := 1; b.h := 1;         VisibleTransfer(w, b)      ELSE        RestoreWindow(w);        Screen.DisplayDot(w^.bm, x, y, m)      END    ELSE      Screen.DisplayDot(w^.bm, x, y, m)    END;  END DisplayDot;  PROCEDURE DisplayChar(w: Window; VAR lineBlk: BlockDescriptor;                        VAR f: Font; ch: CHAR);    VAR b: BlockDescriptor;  BEGIN     IF debug THEN ConsistencyCheck(w) END;    IF w^.overlaid THEN       IF drawbelow AND w^.wptr^.autorestore THEN         b := lineBlk;        Screen.DisplayChar(w^.bm, lineBlk, f, ch);        b.w := lineBlk.x-b.x;        VisibleTransfer(w, b)      ELSE        RestoreWindow(w);         Screen.DisplayChar(w^.bm, lineBlk, f, ch);      END    ELSE Screen.DisplayChar(w^.bm, lineBlk, f, ch);    END;  END DisplayChar;  PROCEDURE ScrollUp(VAR w: Window);     VAR source, dest : BlockDescriptor;  BEGIN    WITH w^.wptr^ DO      IF drawbelow THEN        IF ovi.saved AND NOT autorestore THEN RestoreWindow(w) END;      ELSE        IF ovi.saved THEN RestoreWindow(w) END;      END;      source.x := 0; source.y := 0;       source.h := innerBlock.h-rLine.h;      source.w := innerBlock.w;      dest := source;      dest.y := rLine.h;       BlockTransfer(w, dest, replace, w, source);      source.h := rLine.h;      Replicate(w, source, replace, white)    END  END ScrollUp;  PROCEDURE CarriageReturn(VAR w: Window);  BEGIN     WITH w^.wptr^ DO      rLine.x := 1;      rLine.w := innerBlock.w-2    END;   END CarriageReturn;  PROCEDURE LineFeed(VAR w: Window);  BEGIN     WITH w^.wptr^ DO      IF rLine.h <= rLine.y THEN         DEC(rLine.y, rLine.h);        RETURN       ELSE         ScrollUp(w);      END;     END  END LineFeed;  PROCEDURE Writeln(VAR w: Window);    (* writes the subsequent characters on a new line*)  BEGIN     w^.wptr^.savedEol := FALSE;    CarriageReturn(w);    LineFeed(w);   END Writeln;  PROCEDURE WriteChar(w: Window; ch: CHAR);  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      IF (ch<=36C) OR (ch>=DEL) THEN        IF ch = EOL THEN          IF rLine.y<rLine.h THEN            IF savedEol THEN Writeln(w) END;            rLine.w := 0; savedEol := TRUE;          ELSE Writeln(w) END;        ELSIF drawbelow AND (ch=0C) THEN           IF ovi.saved AND autorestore THEN RepaintVisible(w) END;        ELSIF ch = LF THEN LineFeed(w);          savedEol := FALSE;        ELSIF (ch = DEL) OR (ch = BS) THEN          IF rLine.x > charWmin THEN            DEC(rLine.x, charWmin);            INC(rLine.w, charWmin)          ELSE CarriageReturn(w) END;          IF ch = DEL THEN ClearChars(w, 1) END;        ELSIF ch = FF THEN Clear(w);        ELSIF ch = CR THEN          IF savedEol THEN Writeln(w)          ELSE CarriageReturn(w) END;        ELSIF drawbelow AND (ch=21C (*DC1*)) THEN RestoreWindow(w)        END;        RETURN      END;      IF (NOT drawbelow) AND ovi.saved THEN RestoreWindow(w) END;       IF (rLine.w<charWmax) AND (rLine.w<CharWidth(dfont, ch)) THEN         Writeln(w)      END;      IF drawbelow THEN DisplayChar(w, rLine, dfont, ch)      ELSE Screen.DisplayChar(dbitmap, rLine, dfont, ch)      END    END  END WriteChar;  PROCEDURE ClearChars(w: Window; n: CARDINAL);    VAR blk: BlockDescriptor;  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      blk := rLine;      IF rLine.w DIV charWmax >= n THEN blk.w:= n*charWmax END;      Replicate(w, blk, replace, white);    END  END ClearChars;                           PROCEDURE Clear(w: Window);    VAR      blk: BlockDescriptor;  BEGIN     IF debug THEN ConsistencyCheck(w) END;    IF debugMe THEN CheckList END;    WITH w^.wptr^ DO      (* RestoreWindow(w); but not completely*)      IF         (drawbelow AND ovi.saved AND NOT autorestore)          OR (NOT drawbelow AND ovi.saved) THEN         SaveAllOver(w);        MoveOnTopOfList(w^.wptr);        WriteTitle(w);        ovi.saved := FALSE; w^.overlaid := FALSE;        w^.bm := dbitmap;      END;      blk.x := 0; blk.y := 0;       blk.w := innerBlock.w; blk.h := innerBlock.h;       Replicate(w, blk, replace, white)    END;    SetPos(w, 0, 0);    IF debugMe THEN CheckList END;  END Clear;  PROCEDURE FreeChars(w: Window): CARDINAL;    (* returns number of free characters in the current line *)  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      IF savedEol THEN Writeln(w) END;      RETURN rLine.w DIV charWmax    END  END FreeChars;  PROCEDURE FreeLines(w: Window): CARDINAL;    (* returns number of empty lines; without the current line *)  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      RETURN rLine.y DIV rLine.h    END  END FreeLines;  PROCEDURE GetPos(w: Window; VAR line, pos: CARDINAL);    (* gets position; units are characters and lines *)  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      IF savedEol THEN Writeln(w) END;      IF (rLine.y>innerBlock.h) OR ((innerBlock.h-rLine.y)<=rLine.h) THEN        line := 0      ELSE        line := (innerBlock.h - (rLine.y+rLine.h)) DIV rLine.h;      END;      IF rLine.x=0 THEN pos := 0      ELSE        pos := (rLine.x - 1) DIV charWmin      END    END  END GetPos;  PROCEDURE SetPos(w: Window; line, pos: CARDINAL);    (* sets position; units are characters and lines *)  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      savedEol := FALSE;      rLine.h := charH + charH DIV 10 + 1;      IF (((innerBlock.w-2) DIV charWmin)<pos) THEN pos := 0 END;       IF ((innerBlock.h DIV rLine.h)<(line+1)) THEN line := 0 END;      rLine.w := 0; (*on CTRL-C position is allowed to be false but INSIDE*)      rLine.x := pos*charWmin+1;      rLine.w := innerBlock.w-rLine.x-1;      rLine.y := innerBlock.h - rLine.h*(line+1);    END  END SetPos;  PROCEDURE ClearLines(w: Window; n: CARDINAL);    VAR blk1, blk2: BlockDescriptor; i: CARDINAL;  BEGIN    IF debug THEN ConsistencyCheck(w) END;    WITH w^.wptr^ DO      IF innerBlock.h DIV rLine.h < n THEN        (* clears the whole window *)        WriteChar(w, FF); RETURN      ELSE (* don't clear the whole window *)        ClearChars(w, 177777B);        IF (rLine.x=0) AND (n>0) THEN DEC(n) END;        IF n=0 THEN RETURN END;  (**current microcoding of REPL*)        i := n*rLine.h;        blk1 := innerBlock; blk1.x := 0;        IF rLine.y >= i THEN          (* clears a fraction of the window *)          blk1.h := i;          blk1.y := rLine.y-i;          Replicate(w, blk1, replace, white);        ELSE          (* scrolling is needed *)          n := innerBlock.h DIV rLine.h - n; (*is new line position*)          i := ((innerBlock.h-rLine.y) DIV rLine.h-n)*rLine.h;               (* number of points to scroll*)          blk1.h := n*rLine.h;          blk1.y := innerBlock.h-blk1.h;          INC(rLine.y, i);          blk2 := blk1;           DEC(blk2.y, i);            BlockTransfer(w, blk1 ,replace, w, blk2);          (* clear the rest *)          blk1.h := blk1.y;          blk1.y := 0;          Replicate(w, blk1, replace, white);          IF savedEol THEN Writeln(w) END;        END        END;    END;  END ClearLines;  PROCEDURE SelectWindow(VAR w: Window; x, y: CARDINAL; VAR found: BOOLEAN);    (* Returns a pointer to the window which containins x,y  *)    VAR wPtr: WindowHint;  BEGIN    IF debugMe THEN CheckList END;    wPtr := fullScreenHint^.nextDown;    LOOP       IF wPtr = fullScreenHint THEN         w := NIL; found := FALSE; EXIT       END;      IF InsidePoint(wPtr^.outerBlock, x, y) THEN        w := wPtr^.originalWindow;        IF debug THEN ConsistencyCheck(w) END;        found := TRUE; EXIT      END;      wPtr := wPtr^.nextDown    END;  END SelectWindow;  PROCEDURE NextDown(w: Window): Window;  BEGIN    IF w=NIL THEN       IF fullScreenHint^.nextDown<>fullScreenHint THEN        RETURN fullScreenHint^.nextDown^.originalWindow      ELSE RETURN NIL       END    ELSE      IF debug THEN ConsistencyCheck(w) END;      WITH w^.wptr^ DO        IF normalWindow AND (nextDown<>fullScreenHint) THEN          RETURN nextDown^.originalWindow        ELSE RETURN NIL         END      END    END  END NextDown;  PROCEDURE DefaultWindow(): Window;  BEGIN    RETURN defaultWindow  END DefaultWindow;  PROCEDURE FullScreen(): Window;  BEGIN    RETURN fullScreen  END FullScreen;  PROCEDURE OpenBitmapWindow(VAR w: Window; VAR bmp: Bitmap;               VAR done: BOOLEAN);  BEGIN    NewWindow(w, done);    IF NOT done THEN RETURN END;    WITH w^ DO      (*NEW(wptr);*)       WITH wptr^ DO        ovi.saved := FALSE; ovi.saveBmAlloc := FALSE;        normalWindow := FALSE; dbitmap := bmp;        GetMaxBlock(outerBlock, dbitmap); GetMaxBlock(innerBlock, dbitmap);        nextUp := wptr; nextDown := wptr;        dfont := defaultFont; InitFontData(wptr^);        header[0] := 0c;        originalWindow := w; SetUserFields(w);        SetPos(originalWindow, 0, 0);        signal := IgnoreWindowSignal;        sLevel := SharedLevel(); cLevel := CurrentLevel();        resSystem := NIL; resOwner := NIL;      END;    END;  END OpenBitmapWindow;  (****************)  PROCEDURE WHWrite(ch: CHAR);    (* returns number of free characters in the currend line *)  BEGIN      IF drawbelow AND terminalputontop THEN       IF defaultWindow^.wptr^.ovi.saved THEN RestoreWindow(defaultWindow) END     END;     WriteChar(defaultWindow, ch)  END WHWrite;  PROCEDURE WHFreeChars(): CARDINAL;    (* returns number of free characters in the currend line *)  BEGIN      RETURN FreeChars(defaultWindow)  END WHFreeChars;  PROCEDURE WHFreeLines(): CARDINAL;    (* returns number of empty lines *)  BEGIN     RETURN FreeLines(defaultWindow)  END WHFreeLines;  PROCEDURE WHGetPos(VAR line, pos: CARDINAL);    (* gets position; units are characters and lines *)  BEGIN     GetPos(defaultWindow, line, pos)  END WHGetPos;  PROCEDURE WHSetPos(line, pos: CARDINAL);    (* sets position; units are characters and lines *)  BEGIN     SetPos(defaultWindow, line, pos)  END WHSetPos;  PROCEDURE WHGetDotPos(VAR x, y: CARDINAL);    (* gets position; units are characters and lines *)  BEGIN     GetDotPos(defaultWindow, x, y)  END WHGetDotPos;  PROCEDURE WHSetDotPos(x, y: CARDINAL);  BEGIN     SetPos(defaultWindow, x, y)  END WHSetDotPos;  PROCEDURE WHClearChars(n: CARDINAL);  BEGIN    ClearChars(defaultWindow, n)  END WHClearChars;  PROCEDURE WHClearLines(n: CARDINAL);  BEGIN    ClearLines(defaultWindow, n)  END WHClearLines;  PROCEDURE WHGetDefaultFont(VAR W: WORD);  BEGIN    W := WORD(defaultWindow^.font)  END WHGetDefaultFont;  PROCEDURE WHSetDefaultFont(VAR W: WORD);    VAR fo: Font;  BEGIN    fo := Font(W);    SetFont(defaultWindow, fo)  END WHSetDefaultFont;  PROCEDURE WHGetDefaultBitmap(VAR W: WORD);  BEGIN    W := WORD(defaultWindow^.bm)  END WHGetDefaultBitmap;  PROCEDURE WHSetDefaultBitmap(VAR W: WORD);  BEGIN    (* the WindowHandler disables the procedure Screen.SetDefaultBitmap *)    HALT;  END WHSetDefaultBitmap;  (****************)  PROCEDURE LevelReturn;    VAR winPtr: WindowHint; w: Window; closed: BOOLEAN;   BEGIN closed := FALSE;   IF NOT onReturnFlag THEN     onReturnFlag := TRUE;     IF criticalLevel<CurrentLevel() THEN       HALT (*1 level down *)     END;    criticalLevel := 177777B;    IF debugMe THEN       WriteString("level return "); CheckList;    END;    (*defaults*)    WHILE defaultstack[defaultstackTop].dlevel>=CurrentLevel() DO      DEC(defaultstackTop);    END;    IF (defaultWindow<>defaultstack[defaultstackTop].dwin) THEN      IF (defaultWindow<>NIL) AND (defaultWindow^.wptr<>NIL) AND         (defaultWindow^.wptr^.sLevel<CurrentLevel()) THEN        defaultWindow^.wptr^.signal(defaultWindow, enddefault);      END;      defaultWindow := defaultstack[defaultstackTop].dwin;      defaultWindow^.wptr^.signal(defaultWindow, usedfordefault);    END;    (* reclose the windows where close already was started;        but only if not already taken out of list*)    IF onClosingWindow<>NIL THEN      winPtr := fullScreenHint;      LOOP        winPtr := winPtr^.nextDown;        IF winPtr=fullScreenHint THEN EXIT END;        IF winPtr=onClosingWindow^.wptr THEN           closed := TRUE; CloseWindow(onClosingWindow); EXIT         END;      END;      onClosingWindow := NIL    END;    (*close the windows; this loop is too simple*)    winPtr := fullScreenHint;    LOOP      winPtr := winPtr^.nextDown;      IF winPtr=fullScreenHint THEN EXIT END;      IF (winPtr^.cLevel>=CurrentLevel()) AND (winPtr^.cLevel<>177777B) THEN        w := winPtr^.originalWindow;        closed := TRUE;         CloseWindow(w);        (*restart loop again; the visibility order has changed*)        winPtr := fullScreenHint;      ELSE         InitFontData(winPtr^); (*SetFont has inconsistency if interrupted by CTRL-C*)        SetUserFields(winPtr^.originalWindow)      END    END;    (*return save areas caused from higher level*)    winPtr := fullScreenHint^.nextDown;    WHILE winPtr <> fullScreenHint DO      WITH winPtr^  DO        IF (ovi.saveBmAlloc) AND (ovi.saveBmLev>=CurrentLevel()) THEN          (* all overlaying from higher level is eliminated;              no restore necessary*)          ovi.saveBmAlloc := FALSE;          ReturnBitmap(ovi.saveBmFather);        END;        winPtr := nextDown      END;    END;    FontLevelReturn;    IF (onChangingWindow<>NIL) AND (onChangingWindow^.wptr<>NIL) THEN      WITH onChangingWindow^.wptr^ DO        IF cLevel<CurrentLevel() THEN           signal(onChangingWindow, changed)        END;      END;    END;    onChangingWindow := NIL;    MemLevReturn;    IF debugMe THEN       WriteString("end of termprocedure ");    END;    IF debugMe THEN CheckList END;    IF fullScreenHint^.nextDown<>fullScreenHint THEN       DrawBackGround(absMaxBlk, NIL)     ELSIF closed THEN WriteChar(fullScreen ,14C);     END   END;   onReturnFlag := FALSE;  END LevelReturn;  PROCEDURE DenoteSystemDefaults;    VAR dr: ScreenDriver2.DefaultsRecord;        tr: ScreenDriver2.TextProcRecord;  BEGIN    WITH tr DO      write := WHWrite;      freeLines := WHFreeLines;       freeChars := WHFreeChars;      getPos := WHGetPos;      setPos := WHSetPos;      clearChars := WHClearChars;      clearLines := WHClearLines;      windowHandler := TRUE;    END;    ScreenDriver2.SetProcRec(tr);    WITH dr DO      setDefaultFont := WHSetDefaultFont;      setDefaultBitmap := WHSetDefaultBitmap;      getDefaultFont := WHGetDefaultFont;      getDefaultBitmap := WHGetDefaultBitmap;      setDotPos  := WHSetDotPos;      getDotPos  := WHGetDotPos;    END;    ScreenDriver2.SetDefaultRec(dr);  END DenoteSystemDefaults;  VAR done: BOOLEAN;BEGIN  criticalLevel := 177777B;  (*Screen.LoadFont(headerFont, "HELVETICA16", done);    IF NOT done THEN GetSystemFont(headerFont); END;  *)  GetSystemFont(defaultFont);  headerFont := defaultFont;  headerHeight := FontHeight(headerFont)+ (FontHeight(headerFont) DIV 10)+2;  GetSystemBitmap(fullBitmap);  GetMaxBlock(absMaxBlk, fullBitmap);  OpenBitmapWindow(fullScreen, fullBitmap, done);  IF NOT done THEN HALT END;  fullScreenHint := fullScreen^.wptr;  defaultWindow := fullScreen;  defaultstackTop := 0;  defaultstack[0].dlevel := CurrentLevel()-1; (*must not be resident! [overflow]*)  defaultstack[0].dwin := defaultWindow;  onReturnFlag := FALSE;  onChangingWindow := NIL;  onClosingWindow := NIL;  TermProcedure(LevelReturn);  DenoteSystemDefaults;   IF debugMe THEN CheckList END;END WindowHandler.