Ac
10.  Screen Software
Cc Y15
Christian Jacobi  15.5.82, rev. 28.9.82
+
The screen software chapter describes the following modules:
-f0 x25 t175.
Screen            (10.2.)  
TextScreen        (10.3.)  
WindowHandler     (10.4.)  
CursorStuff       (10.5.)  
CursorRelations   (10.6.)  
WindowDialogue    (10.7.)  
ScreenResources0  (10.8.)  
Lines             (10.9.)  
B Y20
10.1.  Summary
+
For default sequential output the use of module 1Terminal0 is recommended;  the use 
of the higher level modules should be reserved to the case, when the output 
is not strictly sequential.  Terminal is described in an operating system 
description (9.4.) and is not explained in the screen software chapter.

Formatting modules (e.g. 1OutTerminal0, 1OutWindow0) are found in the chapter 11.  

The module 1TextScreen0 supports positioning (and output to) the display screen. 

The module 1Screen0 is the base for all bit directed operations on the display 
terminal.  It contains only a minimum of features: the basic display 
operations, loading of fonts, creation of bitmaps and subbitmaps, and the 
default settings. 

The module 1WindowHandler 0allows the use of windows.  A window is a visible rectangle 
on the screen where text and binary operations are possible.  Such a rectangle
simulates a complete display.  The windows can be compared to pieces
of paper lying on a table.  They can be moved, an overlaid window may be put 
on top, and of course, programs may write or paint into windows.

The module 1CursorStuff0 implements a cursor and allows selection of commands
with a menu. 

1CursorRelations0 imports the cursor position of CursorStuff and computes
the relative cursor position to windows.

With the module 1WindowDialogue0 it is possible to build programs with
independent modules.  The module WindowDialogue collects
the interactive input commands and directs them to the specific windows and 
activities.  The module implements a so called window editor, which allows interactive
modifications of the windows.

1ScreenResources00 is used to get access to resources used by the 
module Screen.

1Lines0 is used to draw straight lines on the screen. 
pB
10.2.  Screen
+
The module Screen implements the 
basic operations with display instructions.  It allocates the resources
and it implements a subbitmap feature.  It exports the hardware functions in a 
controlled manner to the user, i.e. provides
additional validity checks for parameters.
  
+
The Lilith has a raster display as output medium.  The value of each
picture element is independently stored as a bit in a two dimensional array, 
called 1bitmap.0  This bitmap is stored in the main memory.  All 
ordinary data manipulation instructions
may therefore be used to build pictures on the display terminal.  This 
involves great flexibility;
the normal instructions are however usually inadequate for handling images.  
Four specially microcoded instructions are used for that 
purpose (DCH, REPL, BBLT, DDT).  These display instructions are represented
by the display procedures DisplayChar, Replicate,  BlockTransfer and DisplayDot.

The procedure CreateBitmap
allocates a bitmap, and allows use of these operations.  Calling
the procedure ShowBitmap shows
such a bitmap onto the display terminal.  Most applications will
use a bitmap which is already allocated by the system, the procedure
GetDefaultBitmap returns this bitmap in its parameter.  This 1default0 bitmap
is usually shown on the terminal, there is no need to call ShowBitmap with 
this bitmap.  

The display procedures work on rectangles within bitmaps.  Variables of type 
BlockDescriptor are used to describe such rectangles.  A block-descriptor 
describes a rectangle by giving its coordinates of the lower left corner,
its width and its heights.  It is possible to treat such a rectangle like
a bitmap again.  The procedure CreateSubBitmap takes a rectangle inside a 
bitmap and generates an abstract bitmap, denoting that rectangle.  This abstract
bitmap is called a 1subbitmap.0  All operations on bitmaps,
except for ShowBitmap, may also be applied to
subbitmaps.  ShowBitmap is, however, restricted from the 
hardware and displays therefore it's "father"bitmap.  

To be more exact in the former, also the default bitmap could have been changed
to be such a subbitmap.  When several windows are shown, one of these windows
will be used as the default also.  The procedure GetSystemBitmap is used
to get the real 1system0 bitmap.  The system bitmap
may differ from the default bitmap, it is the actual bitmap which 
is allocated by the system, it cannot be changed and denotes the whole 
screen.  The default bitmap is 
the rectangle to which the default output will be directed.  
Usually, the default bitmap is the whole or a part of the system bitmap.  

To write a character, the procedure DisplayChar paints the picture of the 
character into a bitmap.  The procedure copies the character's 
picture from a font table into the bitmap.  The procedure LoadFont
loads a font into a memory area and prepares it for use by DisplayChar.  A
great number of such fonts exist.
C w15
Types Used for Screen Resources
-f7x25
TYPE
  Bitmap; 
  Font;
  BlockDescriptor =
    RECORD
      x, y, w, h: CARDINAL;
    END;
+
1Bitmap0:
A bitmap which can be displayed at the display terminal, or a rectangular 
part of such a 
bitmap.  To 
the programmer, there is no difference between such a rectangle (a subbitmap) 
and the real bitmap, which is the one displayed by hardware; the hardware displays 
only complete bitmaps.  The origin of the coordinate system
is at the lower left corner of the bitmap. 

1Font0: 
Pictures of the characters in a character set. 

1BlockDescriptor0:
Describes a block which is a rectangle inside a bitmap.  x,y are the 
coordinates of the lower left corner of the block, whereas w is the width 
and h the height of the block. 

The structure of the types Bitmap and Font are hidden to the user.  It is
good programming style, not to assign variables of font or bitmap type.
C w15
The Elementary Display Procedures
+
In general, the display procedures work on two rectangles, called the 
source and the destination.
-cf0
destination  :=  F(destination, source)
+
The function F(d, s) depends on the procedure and on a mode 
parameter.

1Mode0:
Mode of operation of the basic display instructions. 
-f7 x25
TYPE
  Mode = (replace,    (* d := s          , s      *)
          paint,      (* d := d OR s     , d+s    *)
          invert,     (* d := d XOR s    , d/s    *)
          erase);     (* d := d AND NOT s, d*(-s) *)
-x25
1replace0: replaces the destination by the source. 
1paint0:    the source is overlaid (added) to the destination. 
1invert0:   the destination is inverted, where the source contains ones. 
1erase0:    the destination is cleared, where the source contains ones. 
+
1BlockTransfer0: is the most general display procedure.  It copies the source 
block into the destination block according 
to the mode.   

1Replicate0: Replicates the bitpattern (pattern) over a rectangle (the destination 
block) of the bitmap according to the mode. 
+x25
1pattern0:
This is not a declared type; any variable may be used as pattern, 
but the first word of the pattern must contain the number of words 
following.  This number is the height of the pattern, its width is 16. 
+

1DisplayDot0: Writes a single dot at the coordinates x, y of the bitmap 
according to a mode. 

1DisplayChar0: Paints the picture of a character from a font table into 
a block of a bitmap.  The position is given by the block (the block denotes
the line).  DisplayChar updates the block
to exclude the just-painted character.  DisplayChar works with paint-mode only;
the block is not previously erased.
-f7 x25

PROCEDURE DisplayChar(VAR bm: Bitmap; VAR lineBlk: BlockDescriptor;
          VAR f: Font; ch: CHAR);
PROCEDURE Replicate(VAR bm: Bitmap; VAR destBlk: BlockDescriptor;
          m: Mode; VAR pattern: ARRAY OF WORD);
PROCEDURE BlockTransfer(VAR dbm: Bitmap; VAR destBlk: BlockDescriptor;
          m: Mode; VAR sbm: Bitmap; VAR sourceBlk: BlockDescriptor);
PROCEDURE DisplayDot(VAR bm: Bitmap; x, y: CARDINAL; m: Mode);

C
Resource Handling
+
The following procedures allocate bitmaps or fonts:
-f7 x25
PROCEDURE CreateBitmap(VAR bm: Bitmap; w, h: CARDINAL; VAR done: BOOLEAN);
PROCEDURE CreateSubBitmap(VAR bm: Bitmap; VAR father: Bitmap;
                          location: BlockDescriptor; VAR done: BOOLEAN);
PROCEDURE LoadFont(VAR f: Font; name: ARRAY OF CHAR; VAR done: BOOLEAN);
+
Creating bitmaps needs their size 7w0 and 7h0 in dots.  7w0 is
augmented to a multiple of 16, since the lines of a bitmap must start
on a word boundary in the memory.  The procedures have a return parameter
7done0.  There are several reasons for malfunction: not enough memory, file
for a font not found, too many resources 
allocated, etc.  The allocation procedures always return to the calling program,
there are no halts.  Calling Loadfont for the same font a second time will 
return a different 
font value, however the actual font table is loaded only once.  To unload
the font table, all font variables pointing to that table must be 
returned.  To use a subbitmap whose "father" bitmap is returned is considered an 
error.

For the procedures to return resources, to set or to query the defaults, see the
definition module.  The procedures SetDotPos and GetDotPos handle the insertion
point, where the default output (from module Terminal) appears on the screen.

+
Furtheron, the specific properties of fonts may be requested:
-f7 x25
PROCEDURE Proportional(VAR f: Font): BOOLEAN;
PROCEDURE FontHeight(VAR f: Font): CARDINAL;
PROCEDURE FontWidth(VAR f: Font): CARDINAL;
PROCEDURE FontBaseLine(VAR f: Font): CARDINAL;
PROCEDURE CharWidth(VAR f: Font; ch: CHAR): CARDINAL;
+
A proportional font is a font with characters of different widths.  FontWidth
returns the maximum character width for proportional fonts.  The procedure
FontBaseLine returns the interval from the bottom of the line used in DisplayChar
to the baseline of the text.
C w15
Size of the Screen
+
Programs should not use knowledge
about the screen size, in order to work properly using different
screen formats.  Further, if a windowhandler is used, a window could 
be denoted to simulate the default screen.  To get
the actual 1size0 of the 1screen0 (compatible to WindowHandler, but without 
importing it), use the following statements:
-f7x25
GetDefaultBitmap(bm);
GetMaxBlock(b, bm)
7b.w0 may be used as screen width, 7b.h0 as height. 
-f0
0Two different hardware displays are used currently:
1)  width 768;  height 592   ("standard" horizontal display)
2)  width 640;  height 832   (new vertical display) 
C w15
Clipping
+
Using blocks which do not fit completely into their bitmap 
is considered as an error, if the bitmap is a real bitmap.  
This error will cause a trap.  For subbitmaps the operation is done with clipped 
blocks and no error occurs.  
+ 
To achieve clipping within a bitmap, it is possible to create a subbitmap of 
the same size and to use the subbitmap instead of the bitmap.
C w15
Restrictions
+
The procedure ShowBitmap requires that a bitmap fulfills some further hardware 
restrictions,
which are not necessarily granted by creating and using bitmaps without displaying them:
+x25 Y2
The width must be a multiple of 64 (dots).  The height must be a multiple of 2.  
+
In DisplayChar the firmware cannot recognize whether or not the character fits 
into the line 
block.  However, it traps if the character would be painted outside the bitmap.

The procedure SetDefaultBitmap is disabled when the WindowHandler is loaded;
in such cases, the WindowHandler takes care of the default bitmap.  

The actual definition module exports some additional private
stuff, needed to implement some system programs.  This stuff
will change on the next version of the operative system.  Therefore
avoid using it, even if you would know the declarations.  The 
module ScreenResources0 gives you indirect access to that private 
stuff, until its improved version will be included in the module Screen.
C w15
Definition Module
-f7 
DEFINITION MODULE Screen;  (* Ch. Jacobi  28.10.81*)
  FROM SYSTEM IMPORT ADDRESS, WORD;
  EXPORT QUALIFIED 
    Bitmap, Font, Mode, BlockDescriptor,
    DisplayChar, Replicate, BlockTransfer, DisplayDot,
    Proportional, FontHeight, FontWidth, FontBaseLine,
    CharWidth,
    GetSystemBitmap, GetSystemFont, 
    GetDefaultBitmap, GetDefaultFont, GetDotPos, 
    SetDefaultBitmap, SetDefaultFont, SetDotPos,
    CreateBitmap, CreateSubBitmap, ReturnBitmap, ShowBitmap,
    LoadFont, ReturnFont, GetFontName,
    IsSubBitmap, GetRealFather, GetRealBlock, GetMaxBlock;

  TYPE
    Bitmap;       
    Font;
    Mode = (replace,  (* d := s           , s      *)
            paint,    (* d := d OR s      , d+s    *)
            invert,   (* d := d XOR s     , d/s    *)
            erase);   (* d := d AND NOT s , d*(-s) *)
    BlockDescriptor =
      RECORD
        x, y, w, h: CARDINAL;
      END;

  PROCEDURE DisplayChar(VAR bm: Bitmap; VAR lineBlk: BlockDescriptor;
                        VAR f: Font; ch: CHAR);
  PROCEDURE Replicate(VAR bm: Bitmap; VAR destBlk: BlockDescriptor;
                      m: Mode; VAR pattern: ARRAY OF WORD);
  PROCEDURE BlockTransfer(VAR dbm: Bitmap; VAR destBlk: BlockDescriptor;
                          m: Mode; 
                          VAR sbm: Bitmap; VAR sourceBlk: BlockDescriptor);
  PROCEDURE DisplayDot(VAR bm: Bitmap; x, y: CARDINAL; m: Mode);

  PROCEDURE Proportional(VAR f: Font): BOOLEAN;
  PROCEDURE FontHeight(VAR f: Font): CARDINAL;
  PROCEDURE FontWidth(VAR f: Font): CARDINAL;
  PROCEDURE FontBaseLine(VAR f: Font): CARDINAL;
  PROCEDURE CharWidth(VAR f: Font; ch: CHAR): CARDINAL;

  PROCEDURE GetSystemBitmap(VAR bm: Bitmap);
  PROCEDURE GetSystemFont(VAR f: Font);
  PROCEDURE GetDefaultBitmap(VAR bm: Bitmap);
  PROCEDURE GetDefaultFont(VAR f: Font);
  PROCEDURE GetDotPos(VAR x, y: CARDINAL);
  PROCEDURE SetDefaultBitmap(VAR bm: Bitmap); 
  PROCEDURE SetDefaultFont(VAR f: Font);
  PROCEDURE SetDotPos(x, y: CARDINAL);

  PROCEDURE CreateBitmap(VAR bm: Bitmap; w,h: CARDINAL; VAR done: BOOLEAN);
  PROCEDURE CreateSubBitmap(VAR bm: Bitmap; VAR father: Bitmap;
                            location: BlockDescriptor; VAR done: BOOLEAN);
  PROCEDURE ReturnBitmap(VAR bm: Bitmap);
  PROCEDURE ShowBitmap(VAR bm: Bitmap);
            
  PROCEDURE LoadFont(VAR f: Font; name: ARRAY OF CHAR; VAR done: BOOLEAN);
  PROCEDURE ReturnFont(VAR f: Font);
  PROCEDURE GetFontName(VAR name: ARRAY OF CHAR; VAR f: Font);

  PROCEDURE IsSubBitmap(VAR bm: Bitmap): BOOLEAN;
  PROCEDURE GetRealFather(VAR fbm, bm: Bitmap);
  PROCEDURE GetRealBlock(VAR blk: BlockDescriptor; VAR bm: Bitmap);
    (* maximal block in coordinates of the real father bitmap of bm*)
  PROCEDURE GetMaxBlock(VAR blk: BlockDescriptor; VAR bm: Bitmap);
    (* maximal block in coordinates of the bitmap bm itself*)

END Screen. 

+f1
Implementation Details
+f3
The modules Screen, Terminal, TextScreen, and WindowHandler use common 
resources.  Your version of Medos uses either module TextScreenDriver 
or module ScreenDriver to coordinate the access to these 
resources.  Depending on which communication module is used,
the system does not remember 
the insertion point on the display terminal after a user program which imports Screen 
terminates (That insertion point is stored in one of the communication modules).

A hidden (empty) module PrivatScreen is imported to force version 
conflicts when the semantics of some private feature changes.  Therefore,
any system program using the private features also imports the module PrivatScreen
to prevent unknown runtime errors.
C w15
Imported Modules
+
The module is distributed in linked form only.
pB
10.3.  TextScreen
+
The module TextScreen allows writing text at arbitrary positions on the display 
terminal.  The definition is made in such a way, that the use of 
the module is also 
possible when the default output is directed to a window.  For proper functionality
a fixed width font has to be used.  With proportional fonts, however, the horizontal
positioning (SetPos, GetPos) is done dotwise.  FreeChars and ClearChars
denote space for maximum width
characters if a proportional font is used. 

The use of this module is recommended if positioning is necessary.  In cases where only a 
scrolling terminal is needed the module Terminal is preferred.  The procedures 
of the module TextScreen may be used intermixed with the procedures of module Terminal.   

The coordinate system used for TextScreen is different to the system
used in module Screen.  TextScreen uses character width and height
as units.  The origin (0, 0) is the first character of the top line.  3(Compared to 
Screen: unit=dots, origin is bottom, left edge of the 
screen).0  The module TextScreen tries to be machine independent, if
fixed width (non proportional) fonts are used.

The font and the default rectangle used for output are modified
with procedures either from module Screen or from module WindowHandler.

C
Definition Module
-f7
DEFINITION MODULE TextScreen;   (* Ch. Jacobi  30.10.80*) 
  EXPORT QUALIFIED Write, FreeChars, FreeLines, 
    GetPos, SetPos, ClearChars, ClearLines;
  (* Text output and positioning relative to the default rectangle used 
     for output. The origin is at the upper left corner of the rectangle. 
     Units of the coordinates are characters and lines, starting with 0.  
     Uses fixed-width font.  *)
  PROCEDURE Write(ch: CHAR);
  PROCEDURE FreeChars(): CARDINAL;
    (* returns number of free characters in the current line *)
  PROCEDURE FreeLines(): CARDINAL;
    (* returns number of empty lines *)
  PROCEDURE GetPos(VAR line, pos: CARDINAL);
  PROCEDURE SetPos(line, pos: CARDINAL);
  PROCEDURE ClearChars(n: CARDINAL);
    (* clears n positions but at most the rest of the current line *)
  PROCEDURE ClearLines(n: CARDINAL);
    (* clears n full lines but at least the rest of the current line *)
END TextScreen.

C
Imported Modules
+
The module is distributed in linked form only.
pB
10.4.  WindowHandler
+
This module allows the use of windows.  A window is a visible rectangle 
on the screen where text and binary operations are possible.  Such a rectangle
simulates a complete display.  The windows may be considered as pieces
of paper lying on a table.  They may be moved; an overlaid window may be put 
on top. 

Typical text 
operations are writing and positioning; typical binary operations are 
replicate and blocktransfer.  In addition to the procedures for manipulations 
inside windows, the module supports creation, deletion...  of windows
and it handles their overlapping.
Cf1 w15
Window Output Handling Procedures
+
The output procedures for binary output correspond exactly to the fullscreen 
output procedures of the module Screen.  The text handling procedures correspond 
to those of the module TextScreen.  Further some procedures allow combination 
of binary and text operations. 
- t 75 185.
- for binary output:
     Replicate,     BlockTransfer,
     DisplayDot,    DisplayChar
-
- for text handling:
     WriteChar,  
     FreeChars,     FreeLines,
     GetPos,        SetPos,       
     ClearChars,    ClearLines
- 
- for combination:
     Clear,
     GetDotPos,     SetDotPos
Cf1 w15
Window Management Procedures 
+
Procedures to create, move, 
eliminate, ...  windows and to handle fonts. 
-
- window management:
     CreateWindow,  ChangeWindow,
     OpenWindow,    CloseWindow
- 
- font handling:
     LoadFont,      SetFont 
- 
- visibility operations:
     PutOnTop,      SaveWindow,     
     NextDown    
- 
- dummy procedure used for creation:
     IgnoreWindowSignal
Cf1 w15
Context Management Procedures
-
- handling of default output:
     UseForDefault, DefaultWindow
- 
- full screen operations:
     SelectWindow,  FullScreen
- 
- use of (Screen) bitmaps as windows:
     OpenBitmapWindow
p Cf1
Remark
+
The windowhandler may be used without import of the module Screen.  Using
the same types for Font, Bitmap, BlockDescriptor and Mode serves only 
for compatibility
of 1intended0 common use of these two modules.  So does the procedure 
OpenBitmapWindow.  If these type declarations would be replaced
by their actual definition and the procedure OpenBitmapWindow would be eliminated,
the module WindowHandler would be independent; it would not be necessary to explain
references to other modules.
-f7x25
TYPE
  Bitmap;                   (*0used for compatibility with module Screen7*)
  Font;                     (*0picture of the characters7*)
  BlockDescriptor =         (*0rectangle inside a window7*)
    RECORD
      x, y, w, h: CARDINAL;
    END;
C w15
The Window Type
+
Windows are represented by an abstract data type.  The type Window itself
is a pointer to a descriptor. This descriptor describes some public
features of the window.
-f7x25
TYPE
  Window = POINTER TO WindowDescriptor;
  WindowDescriptor =
    RECORD                       
      wptr:      WindowHint;       (* do not access *)        
      bm:        Bitmap;           
      font:      Font;            
      overlaid:  BOOLEAN;          (* window not completely visible *)
      outerblk:  BlockDescriptor;  (* in coordinates of the original bitmap *)
      innerblk:  BlockDescriptor;  (* in coordinates of the original bitmap *)
      header:    ARRAY [0..N-1] OF CHAR;
    END;
+f0Y2
All fields are 1read-only.0

7wptr0:  for use by the implementation module only. 

7bm0:  allows combination of operations of module Screen with module 
WindowHandler.  7bm0 is the bitmap which corresponds to the 
inner (writable) area of a
window.  7bm0 is not valid while the window is overlaid. 

7font0:  this font will be used on "Write" operations for the window.

7overlaid0:  flag, if some part of the window is overlaid.  A window which is overlaid
is put on top before it is written. 

7outerblk0:  coordinates of the window inclusive its border.

7innerblk0:  coordinates of the inner area of the window.  Only this 
area can be modified
with write and paint procedures.  Note: The coordinates used are relative to the 
full screen.  Windowhandler operations use window-coordinates: 0,0 is at the lower left
point inside the window.

7header0:  title, written on top of the window. 
+
It is important, that the type Window is a pointer.  Window variables may
be assigned, function procedures may return windows.  The descriptor is
allocated by the windowhandler and must not be copied (since the implementation
may be position dependent).  The fields are read-only and may change
at any time.
C w15
Allocation of Windows
+
The simplest method to open (create) a new window is to call the procedure
OpenWindow:
-f7x25
PROCEDURE OpenWindow(VAR w: Window; x, y, width, height: CARDINAL;
                      name: ARRAY OF CHAR; VAR done: BOOLEAN);
7w0:  is the new window
7x, y0:  coordinates of the (left, bottom) edge of the border
7width, height0:  of the window (including the border)
7name0:  title of the window
7done0:  returns success 
+
It is necessary to check the 7done0 parameter, there exist several reasons
for failures of the operation: not enough memory, too many windows, bad coordinates, etc.

The more complete procedure CreateWindow has two additional parameters:
-f7x25
PROCEDURE CreateWindow(VAR w: Window;
            x, y, width, height: CARDINAL;  
            name: ARRAY OF CHAR;                 
            savecontents: BOOLEAN;               
            signal: WindowProc;  
            VAR done: BOOLEAN);
+
7savecontents0:  selects the method of handling the window
when it is overlaid.
+Y2
7signal0:  is a procedure which is called when some operations occur. 
+
(OpenWindow corresponds to CreateWindow where the signal's are ignored, and the 
windowhandler saves the contents of the window).
Cf1 w15
WindowSignals
+
When windows are modified, the modification is notified to the "owner" program (the 
program which called 
CreateWindow).  Upon creation of 
the window a "signal" procedure (of type WindowProc) is specified.  The signal 
procedure is called when the window is modified.  The signal procedure 
may inspect its parameter to get information about which 
modification of which window occured. 
-f7x25
TYPE
  WindowSignal = (redraw, save, 
                  moved, changed, fontchanged, opened, closed,
                  usedfordefault, enddefault, ...);
  SignalSet  = SET OF WindowSignal;
  WindowProc = PROCEDURE(Window, WindowSignal);
+
Note: The "signal" procedure is not only called during the creation of the window; it
is also called later, when some action happens.  Signal procedures 
may be compared to asynchronous interrupts.
Cf1 w15
Overlapping
+
Windows may freely overlap each other.  It is, however, possible
to put any window on the top at any time.  There are two methods to redraw a window
when it is put on the top (savecontents parameter of CreateWindow). 
+x25
If the windowhandler saves the contents of the window itself, then it 
redraws the window itself.  The signal procedures may then be used to 
notify the action.  

If the windowhandler does not saves the contents, then the owner of the
window has to redraw it whenever the windowhandler requests redrawing by a 
call of the corresponding signal procedure.  
Cf1 w15
Handling WindowSignals
-f7
- 7redraw, save:7
        0if restoring is done automatically7 (savecontents=TRUE)
              0the signal procedure is called after the window has been saved,7
              0respectively redrawn;7
              0(No signal of redraw when 7Clear0 puts the window on top)7 
        0if window is not restored automatically7 (savecontents=FALSE)7
              0this is a request to the owner to save or to redraw the window;7
              7save:   0when called, the window is visible7
              7redraw: 0when called, the window is visible but cleared7
- 7moved, changed:7
        0if restoring is done automatically7
              0called after the action has been done7  
        0if not restored automatically7
              0this call replaces a redraw signal; it is a request to draw the window7
              0on its new position7
- 7fontchanged, opened:7
        0called after the action has been done7  
- 7closed:7
        0called before the window disappears7 
- 7usedfordefault, enddefault:7
        0notifies the action7 
- 0other values:0  should be ignored by user programs.
+
If a window should not signal its operation, it may use IgnoreWindowSignal
as its signal procedure.
C w15
The Binary Display Procedures
+
In general, the display procedures work on two rectangles within windows, called the 
source and the destination. 
-cf0
destination  :=  F(destination, source)
+
The function F(d, s) depends on the procedure and on a mode 
parameter.

These blocks are described with the BlockDescriptor 
type.  The coordinate system used for these blocks has its origin
at the lower left corner of the window.

1Mode0:
Mode of operation of the basic display procedures. 
-f7 x25
TYPE
  Mode = (replace,    (* d := s          , s      *)
          paint,      (* d := d OR s     , d+s    *)
          invert,     (* d := d XOR s    , d/s    *)
          erase);     (* d := d AND NOT s, d*(-s) *)
-x25
1replace0: replaces the destination by the source. 
1paint0:    the source is overlaid (added) to the destination. 
1invert0:   the destination is inverted, where the source contains ones. 
1erase0:    the destination is cleared, where the source contains ones. 
+
1Clear0: Clears the window.

1Replicate0: Replicates the bitpattern (pattern) over a rectangle (the destination 
block) of the window according to the mode. 
+x25
1pattern0:
This is not a declared type; any variable may be used as pattern, 
but the first word of the pattern must contain the number of words 
following.  This number is the height of the pattern, its width is 16. 
+

1BlockTransfer0: is the most general display procedure.  It copies the source 
block into the destination block according to the mode.   

1DisplayDot0: Writes a single dot at the coordinates x, y of the window 
according to a mode. 

1DisplayChar0: Paints the picture of a character from a font table into 
a block of a window.  This block represents the position (line).  DisplayChar 
updates the block to exclude the just-painted character. 
-f7 x25
PROCEDURE Clear(w: Window);
PROCEDURE Replicate(w: Window; VAR dest: BlockDescriptor;
          m: Mode; VAR pattern: ARRAY OF WORD);
PROCEDURE BlockTransfer(dw: Window; VAR dest: BlockDescriptor;
          m: Mode; sw: Window; VAR source: BlockDescriptor);
PROCEDURE DisplayDot(w: Window; x, y: CARDINAL; m: Mode);
PROCEDURE DisplayChar(w: Window; VAR lineBlk: BlockDescriptor;
          VAR f: Font; ch: CHAR);
+ w15
1Implementation Restrictions0

The current implementation does not
guarantee correct blocktransfer, if the source and the destination
windows overlap each other.

The destination blocks will be clipped to the window's size.  The procedure
DisplayChar does not recognize whether or not the character fits into the line block.
C w15
Text Output
+
The text output procedures are defined in such a way that they could be
used without any respect to the binary procedures.  These procedures
have their own coordinate system for positioning: The origin (0, 0) is
the first character of the first line in the window.  Units are the line height and 
the character width (if the font is not proportional).  

For the procedure declarations see the definition module; the procedures
correspond to those of the module TextScreen.

The output and the positioning is done with the default font associated to the 
window.  The procedures LoadFont and SetFont are used to exchange the default 
font of a window, the font which is
used by the procedure WriteChar.  It is up to the user's responsibility
not to return the font explicitly (Procedure ReturnFont of module 
Screen).  The windowhandler's implementation may (but need not) return 
fonts which were
loaded with the procedure LoadFont of the windowhandler.

If a proportional font is used
the positioning is a bit clumsy.  The procedure GetPos and SetPos will
use dot coordinates for the horizontal coordinate.  The procedures
ClearChars and FreeChars will use maximum width characters.

The procedures GetDotPos and SetDotPos allow positioning text output with the
binary (dot) coordinate system.
C w15
Default Output
+
When the windowhandler is initialized, the first window which is created
will be used as 1default window0.  The procedure UseForDefault allows to exchange
the default window.  Library modules must not call this procedure, since 
their callers may make assumptions where the default output will be 
written.  The procedure 
DefaultWindow returns the window
where default output will be directed to.

Whether the windowhandler is used or not, need not be known by library
modules.  If it is used, the default window is also used to display 
the default output
written with module Terminal.  Default output should not use knowledge
about screen size, because it may be directed to a window.  It is
possible to get the size of the default window without importing the
module WindowHandler 3(See description of module Screen).0
C w15
Miscellaneous Procedures
+
The procedure SelectWindow is used in many applications.
-f7x25
PROCEDURE SelectWindow(VAR w: Window; x, y: CARDINAL; VAR found: BOOLEAN);
  (* Returns the window (w) in which the point x,y is visible;
     found: x, y points to a window *)
+
If a point is selected (e.g. with mouse actions) the procedure returns
which window contains the point.  If an object in a partly overlaid window gets 
selected, this procedure allows detection whether or not the object was visible:  Since
the actual Window type is a pointer, it is allowed to compare the returned window
with another window and to check if they are the same.  3(This was the real cause
to design the type Window to be a pointer).0

The procedure FullScreen returns the 1dummy0 window which denotes
the whole screen.  This dummy window enables drawing outside the windows,
it is, however, up to the user's responsibility not to modify other windows.  

The procedure PutOnTop moves an overlaid window on the top, this window then may lie
over
other windows.  Do not assume a window to remain on top, any output of any module may 
cause a change of the window order.  

For further procedures see the definition module.
C w15
Reference
+
The Modula-2 manual [1] shows a subset of the windowhandler.  This subset
fulfills the need of most applications.  There is also an example of
the use of the windowhandler. 
C w15
Definition Module
-f7
DEFINITION MODULE WindowHandler;  (* Ch. Jacobi  9.12.81*)
  FROM SYSTEM IMPORT WORD, ADDRESS;
  IMPORT Screen; 

  EXPORT QUALIFIED
    Window, 
    Bitmap, Font, BlockDescriptor, Mode,
    WindowDescriptor, WindowSignal, SignalSet, WindowProc,
    CreateWindow, OpenWindow, CloseWindow, ChangeWindow, 
    Clear,
    Replicate, BlockTransfer, DisplayDot, DisplayChar,
    WriteChar, 
    FreeChars, FreeLines, GetPos, SetPos, ClearChars, ClearLines,
    SetDotPos, GetDotPos, 
    LoadFont, SetFont, 
    UseForDefault, DefaultWindow, 
    PutOnTop, NextDown, SaveWindow, 
    SelectWindow, FullScreen, 
    OpenBitmapWindow, IgnoreWindowSignal;

  CONST N = 24;
  TYPE
    Window          = POINTER TO WindowDescriptor;
    Bitmap          = Screen.Bitmap;          (* Bitmap; *)
    Font            = Screen.Font;            (* Font; *)
    BlockDescriptor = Screen.BlockDescriptor; (* RECORD x,y,w,h: CARDINAL END; *)
    Mode            = Screen.Mode;            (* (replace, paint, invert, erase); *)
    WindowHint;
    WindowDescriptor =
      RECORD                       
        wptr:      WindowHint;       (* do not access *)        
        bm:        Bitmap;          
        font:      Font;            
        overlaid:  BOOLEAN;          (* window not completely visible *)
        outerblk:  BlockDescriptor;  (* in coordinates of the original bitmap *)
        innerblk:  BlockDescriptor;  (* in coordinates of the original bitmap *)
        header:    ARRAY [0..N-1] OF CHAR;
      END;
      (* do not make copies of windowdescriptors;
           all fields are considered read-only,
           the fields may dynamically change values *)
    WindowSignal = (redraw, save, 
                    moved, changed, fontchanged, opened, closed,
                    usedfordefault, enddefault, ...);
    (* - 1redraw, save:7
              if not restored automatically7
                  requests on the owner;7
                  1save:   7when called, the window is visible7
                  1redraw: 7when called, the window is visible but cleared7
              if restoring is done automatically7
                  is called after the action has been done;7 
                  No call of redraw when Clear puts the window on top7 
       - 1moved, changed:7
              if restoring is done automatically7
                  called after the action has been done;7
              if not restored automatically7
                  this call replaces a redraw signal; it is a request7
       - 1fontchanged, opened:7
              called after the action has been done7
       - 1closed:7
              called before the window disappears7 
       - 1usedfordefault, enddefault:7
              notifies the action7 
       - 1other values:7  should be ignored by user programs.7 *)
    SignalSet  = SET OF WindowSignal;
    WindowProc = PROCEDURE(Window, WindowSignal);

  PROCEDURE CreateWindow(VAR w: Window;
              x, y, width, height: CARDINAL;  
              name: ARRAY OF CHAR;                 
              savecontents: BOOLEAN;               
              signal: WindowProc;  
              VAR done: BOOLEAN);
    (* w: new created window
       x, y: coordinates of the (left, bottom) edge of the border 
       width, height: of the border
       name: title of the window
       savecontents: pointwise saved and restored on overlapping 
       signal:   procedure called when an event to signal occurs
                 Warning: signal must not cause operations on other windows;
                          otherwise infinite loops may be programmed
       done: returns success *)
                                                   
  PROCEDURE OpenWindow(VAR w: Window; x, y, width, height: CARDINAL;
                        name: ARRAY OF CHAR; VAR done: BOOLEAN);
    (* w: new created window
       x, y: coordinates of the (left, bottom) edge of the border 
       width, height: of the border
       name: title of the window
       done: returns success 
       [OpenWindow is short form of CreateWindow with
        savecontents  := TRUE;  signal  := IgnoreWindowSignal] *)

  PROCEDURE CloseWindow(VAR w: Window);

  PROCEDURE ChangeWindow(w: Window; x, y, width, height: CARDINAL;
                         VAR done: BOOLEAN);

  (* 1operators7 *)
  PROCEDURE Clear(w: Window);
  PROCEDURE Replicate(w: Window; VAR dest: BlockDescriptor;
                          m: Mode; VAR pattern: ARRAY OF WORD);
    (* a pattern contains the size of its image in the first word,
       followed by the image *)
  PROCEDURE BlockTransfer(dw: Window; VAR dest: BlockDescriptor;
                          m: Mode; sw: Window; VAR source: BlockDescriptor);
    (* transferring between overlapping windows is not guaranteed 
       in the current implementation*)
  PROCEDURE DisplayDot(w: Window; x, y: CARDINAL; m: Mode);
  PROCEDURE DisplayChar(w: Window; VAR lineBlk: BlockDescriptor;
                        VAR f: Font; ch: CHAR);

  (* 1Text Windows; positioning only with non proportional fonts7 *)
  PROCEDURE WriteChar(w: Window; ch: CHAR);
  PROCEDURE FreeChars(w: Window): CARDINAL;
    (* returns number of free characters in the current line *)
  PROCEDURE FreeLines(w: Window): CARDINAL;
    (* returns number of empty lines; the current line not counted *)
  PROCEDURE GetPos(w: Window; VAR line, pos: CARDINAL);
  PROCEDURE SetPos(w: Window; line, pos: CARDINAL);
  PROCEDURE ClearChars(w: Window; n: CARDINAL);
    (* clears n positions but at most the rest of the current line *)
  PROCEDURE ClearLines(w: Window; n: CARDINAL);
    (* clears n full lines but at least the rest of the current line *)

  (* 1positioning with dot coordinates7 *)
  PROCEDURE GetDotPos(w: Window; VAR x, y: CARDINAL);
  PROCEDURE SetDotPos(w: Window; x, y: CARDINAL);

  PROCEDURE LoadFont(w: Window; fontName: ARRAY OF CHAR; VAR ok: BOOLEAN);
  PROCEDURE SetFont(w: Window; VAR f: Font);
 
  (* 1defaults7 *)
  PROCEDURE UseForDefault(w: Window);
    (* denote the system to use this w as default Window*)
  PROCEDURE DefaultWindow(): Window;

  (* 1visibility7 *)
  PROCEDURE PutOnTop(w: Window);
  PROCEDURE NextDown(w: Window): Window;
    (* w=NIL:  gets the window on top
       w<>NIL: gets the window below of w
               if w is bottom window: returns NIL. 
       The window list is ordered according to visibility 
       (overlaying of windows); when the visibility changes while
       following the list, windows may be overseen or seen twice ! *)
  PROCEDURE SaveWindow(w: Window): BOOLEAN;
    (* the window w will be saved,
       this allows to overlay the visible look of the window on the 
       screen, on further WindowHandler operations the window will 
       first be redrawn. *)
      
  (* 1special7 *)
  PROCEDURE SelectWindow(VAR w: Window; x, y: CARDINAL; VAR found: BOOLEAN);
    (* Returns the window in which the point x,y is visible*)
  PROCEDURE FullScreen(): Window;
    (* the dummy window which denotes the whole screen; *) 
  PROCEDURE OpenBitmapWindow(VAR w: Window; VAR bm: Bitmap; VAR done: BOOLEAN);
    (* enables WindowHandler operations onto bitmaps (of module Screen). 
       A bitmap window cannot be changed or moved;
       it is not included in the window list available  
       by calling NextDown;
       it is not tested against visibility nor overlapping *)
  PROCEDURE IgnoreWindowSignal(w: Window; s: WindowSignal);
    
END WindowHandler. 

C
Imported Modules
-f0x25
Screen
Terminal
FileSystem
Others, which either are resident, or linked to the module WindowHandler.
pB
10.5.  CursorStuff
+
Simple 1cursor handling0 and 1menu input0 technique.  
The module supports three different levels of implementation.

The normal, high level use is provided by the procedures TrackCursor, ReleaseCursor,
and MenuSelection.  The position of the mouse is saved in global variables.

The unsymmetry between
these procedures is necessary!  TrackCursor returns whenever a button is 
pressed.  Always one button is pressed first, this button is specified in the return 
value.  ReleaseCursor returns when no button is pressed, i.e. after a release 
of the buttons.  This allows to return the set of all buttons, 
which have been pressed after
the procedure was called.  

MenuSelection draws a menu and waits until the user selects one of the commands 
of the menu (by releasing the mouse buttons when the cursor lies on
the corresponding command), or does another manipulation.  
Normally the mouse buttons are pressed before the procedure is called,
and the command are selected by releasing the buttons.  But, if MenuSelection 
should first wait till a button is pressed and only after that may exit, 
the commandstring should start with a "*".

The procedure GetMouse (lower level) simply gets the mouse coordinates into 
the variables xpos, ypos and
reads the state of the buttons.  In fact, 
the procedure gives not only the hardware coordinates, it also maps the hardware 
coordinates 
onto the screen size.  The moving of the cursor is delayed at the border of the screen
(this allows exact positioning onto the border).  However, moving the mouse further 
causes the cursor to wrap around.

On a middle level, the procedures TrackCursor and ReleaseCursor are used 
again, but 
an own cursor procedure is used.  Calling InstallCursor tells the
module to install the users cursor tracking procedure for the next call 
of TrackCursor or ReleaseCursor.  It is not recommended
to use this middle level 
for simple programs, it is, however, used to
implement the menu selection procedure.   Further, the module exports 
the procedures ArrowInvert and
SimpleMove, which are installed,
when no user installations are done.
C w15
Definition Module
-f7
DEFINITION MODULE CursorStuff;  (* Ch. Jacobi  2.8.81*)
  EXPORT QUALIFIED
    MenuSelection, TrackCursor, ReleaseCursor, xpos, ypos,
    InstallCursor, ArrowInvert, SimpleMove,
    buttons, GetMouse;

  (* 1high level features7 *)

  VAR xpos, ypos: CARDINAL;

  PROCEDURE MenuSelection(s: ARRAY OF CHAR): CARDINAL;
     (* The menu is painted near to the position (xpos, ypos).
        s: max 9 commands
            "  title | comm-2 | comm-3 | ...| comm-n"     OR     
            "* title | comm-2 | comm-3 | ...| comm-n"    (waits first)   
        the "*" is used when no button was pressed previously.   
        returns:
        0:    not selected:
                a key on the keyboard has been pressed.  The key 
                pressed is put back into the input buffer and 
                can be read with Terminal.Read;
        1:    not selected:
                tried to select title or outside the menu;
        2..n: the corresponding command has been selected  *)
p
  PROCEDURE TrackCursor(): CARDINAL;
    (*returns 0: keyboard 1: left button; 2: middle; 3: right; 
      does cursor tracking; returns when the first button (or key) 
      is pressed while cursor tracking *)

  PROCEDURE ReleaseCursor(wait: BOOLEAN; VAR but: BITSET);
    (* {1}: left button; {2}: middle; {3}: right; {0}: keyboard;
       if wait is set and no button is pressed at initialization time, then 
           ReleaseCursor does cursor tracking till any button
           is pressed, then continues cursor tracking and returns when 
           all buttons are released.  
           (but returns as soon a key is pressed)
        else 
           does cursor tracking; returns when all buttons are 
           released (or a key is pressed) *)   

  (* 1lower level features7 *)

  VAR buttons: CARDINAL;
 
  PROCEDURE GetMouse;
    (* reads the mouse status; sets xpos, ypos, buttons *)
  PROCEDURE InstallCursor(invertproc, moveproc: PROC);
    (* the next call of TrackCursor or ReleaseCursor uses invertproc to draw
       and to erase the cursor; moveproc to move the cursor *)
  PROCEDURE ArrowInvert;
  PROCEDURE SimpleMove;
    (* does the move through inverting twice *)

END CursorStuff. 

C
Restrictions
+
The global variables are read-only.  (Assgning a value to them may destroy information 
used by other utilities or by the user;  the module CursorStuff is not affected.)
C w15
Example
-f7
   LOOP
     (*1 assume no button is pressed7 *)
     CASE MenuSelection("* MENU | comm-A | comm-B | EXIT") OF
       0: Read(ch); Write(ch) |
       1: WriteString("please select a command") |
       2: ProcA |
       3: ProcB |
       4: EXIT
     END;
   END;
+
or:
-f7
   i := TrackCursor(); (*1 draws and moves the cursor7 *)
                       (*1 a button is pressed down7 *)
   IF i=1 THEN
     (*1 the (left) button is probably still pressed down7 *)
     CASE MenuSelection(" MENU | comm-A | comm-B") OF
       0: BusyRead(ch)|
       1: WriteString("no command selected")|
       2: ProcA |
       3: ProcB 
     END;
   ELSE.....

C
Imported Modules
-f0x25
Terminal
Screen
Resident system modules
pB
10.6.  CursorRelations
+
Cursor-positions relative to windows

+
All procedures take the position where the mousebuttons have been pressed 
the last time and compute offsets to the window used as parameter.  For the 
characterwise relative positions the default font of the window is used (The font 
which would be used by the procedure WriteChar).  For 
the procedure DownCharPos and RightCharpos, (0, 0) is the position of the
first character of the top line.  The procedure 
UpDotPos and RightDotPos use the dot coordinate system of the window;
(0, 0) denotes the position of
the leftmost point of the bottom line.
C w15
Definition Module
-f7
DEFINITION MODULE CursorRelations;  (* Ch. Jacobi 10.6.81*)
  FROM WindowHandler IMPORT Window;
  (*IMPORT CursorStuff*)
  EXPORT QUALIFIED
    Inside,
    DownCharPos, RightCharPos,
    UpDotPos, RightDotPos;

  (* all coordinates are relative to
     CursorStuff.xpos, CursorStuff.ypos *)
 
  PROCEDURE Inside(w: Window): BOOLEAN;
  PROCEDURE DownCharPos(w: Window): CARDINAL;
  PROCEDURE RightCharPos(w: Window): CARDINAL;
  PROCEDURE UpDotPos(w: Window): CARDINAL;
  PROCEDURE RightDotPos(w: Window): CARDINAL;

END CursorRelations.

C
Restrictions
+
Relations are taken between the cursor position at cursor tracking time and 
the window position at current time; Changes of the window in the mean time
would cause wrong results.

The windows have to be properly initialized.

The results are unpredictable, if the cursorposition is not inside the inner 
area of the window (Not so for the procedure Inside).
C w15
Imported Modules
-f0x25
Screen
CursorStuff
WindowHandler
pB
10.7.  WindowDialogue
+
Window Editor and Input Scheduler. 

This module collects
the interactive input commands and directs them to the specific windows and their
activities.  The module implements a so-called 1window editor0, which allows interactive
modifications of the windows.
C w15
The Window Editor
+
If a mouse button is clicked while the cursor shows to the background,
a control menu is shown.  The commands shown allow to modify 
windows.  After selecting a command,
a window has to be pointed at; the
command is relative to that window.  Note: Only those actions will happen
to a window, which explicitly were installed by a previous 
call of InstallWindow.

The call feature is dangerous, an interactively selected and executed erroneous
program may
cause the calling program to abort.  To avoid this, the call feature is discarded
when the procedure DialogLoop was called with its parameter 7comint=FALSE0.
+f1 w15
Interactive Commands of the Window Editor0
+f7x25
exit: 0 
+x50 Y2
Exits the most recent invocation of DialogLoop; usually programs then will terminate.
+f7x25
call: 0 
+x50 Y2
Shows another menu.  Selects a utility program and
executes it.  (Either directory, copy, delete, rename,
list or other important routines)  If the utility-menu is
discarded and the keyboard is pressed, it starts a
command interpreter, reads a program name and executes
that program inside the window.  (Press 7ESC0 to quit the command 
interpreter).  It is 
possible to run out of memory or to get
other loader or execution error messages.  The call
command allows creation of an own, temporary window if
no window is selected. 
+f7x25
remove: 0 
+x50 Y2
Removes the Window.
+f7x25
move: 0 
+x50 Y2
Moves the window.  Asks the user to point the new
location.
+f7x25
change: 0 
+x50 Y2
Changes the window size or location.  Asks the user to
point the new diagonal of the window.
+f7x25
font: 0 
+x50 Y2
Set font used for the window.  
+f7x25
order: 0 
+x50 Y2
Shows another menu with names of windows.  Select a window to be placed on
top (made visible).
+
If no menu command is selected, but the mouse button is released while the
cursor square points to a window, this window is placed on
top (made visible).

To escape from a started command press 7ESC.0
C w15
Warning
+
This module is a step forward to an integrated system.  In spite of this, the use
of such a module is not freely recommended.  Actions are executed on the top 
program level.  All actions which return or require some resources will do this
on that top level.  When the operating system will allow resource
allocation on another level and will support some kind of multiprogramming, then 
the operating system will take over the job of distributing the input to the
proper program.  It will do it in a nicer way than with these handler-procedures,
eg. with processes. 

However, if use for combination of independent
1programs0 is not without problems, this module is very useful for importing
independent (library) 1modules0.
C w15
Definition Module
-f7
DEFINITION MODULE WindowDialogue;  (* Ch. Jacobi  14.12.81*)

  FROM WindowHandler IMPORT
    Window, WindowSignal, SignalSet, WindowProc;
  EXPORT QUALIFIED
    DialogProc, 
    InstallWindow, CreateInstallWindow, RemoveWindow,
    InstallKeyboard,
    DialogLoop, EndLoop;

  (* procedures to install "handlers" which are called on specific
     actions done with or inside a window;
     [the handlers are only called, if the action is caused from within this module]
     all installations are active only while the procedure DialogLoop

    DialogActions: 
        1 - left   button pressed inside the window
        2 - middle    "      "       "    "    "
        3 - right     "      "       "    "    "
        4 - commandinterpreter called inside the window
              (executing programs elsewhere is not recorded)
        5 - remove command interactively called 
       15 - enables dialog actions caused from higher, non shared levels *)

  TYPE DialogProc = PROCEDURE(Window, CARDINAL);
         (* the window parameter describes with which window an action happened;
            the CARDINAL describes the DialogAction which happened *)

  PROCEDURE InstallWindow(w: Window; 
              dialogActions: BITSET;          (*interactive allowed dialog actions*)
              dialogHandler: DialogProc;      (*called on dialog actions*)
              windowHandlerActions: SignalSet;(*interactive allowed WH actions*)
              VAR done: BOOLEAN);

  PROCEDURE CreateInstallWindow(VAR w: Window; name: ARRAY OF CHAR;
              dialogActions: BITSET;          (*interactive allowed dialog actions*)
              dialogHandler: DialogProc;      (*called on dialog actions*)
              windowHandlerActions: SignalSet;(*interactive allowed WH actions*)
              savebitwise: BOOLEAN;           (*WindowHandler*)
              signal: WindowProc;             (*WindowHandler; called on WH action*)
              VAR done: BOOLEAN);
    (* corresponds to :
         interactive position query; CreateWindow; InstallWindow
         dialogActions:        interactive allowance by this module
         windowHandlerActions: INTERACTIVE allowance by this module;
                               (if called explicitly all actions are allowed
                                since the WindowHandler ignores this module)
         dialogHandler:        handler called on all dialog actions
         signal:               handler called on all WindowHandler actions;
                               (don't care about interaction or not)
                               for exact definition see WindowHandler
         savebitwise:          the WindowHandler saves the image on overlapping
                               for exact definition see WindowHandler*)

  PROCEDURE RemoveWindow(w: Window);
    (* cancel the installation, does not close the window*)

  PROCEDURE InstallKeyboard(p: PROC);
    (* p will be called when a key (keyboard) is pressed *)

  PROCEDURE DialogLoop(comint: BOOLEAN);
    (* starts a main loop which calls the installed handler procedures
       according to the interactive actions of the user. 
       it may be stopped interactively or 
       programmed by calling EndLoop;
       comint: allows calling the command interpreter interactively*)              

  PROCEDURE EndLoop;
    (* stops the dialog loop *)

END WindowDialogue.

+f3
Fine point:  The procedure DialogLoop considers the top line of the screen 
to be background.  This allows
selection of the window-editor, if the background is not visible at all.
C w15
Imported Modules
-f0x25
Terminal
WindowHandler
FileNames
Program
ProgramMessage
CursorStuff
Screen
Some resident system modules
pB
10.8.  ScreenResources0
+
Gives access to actual resources used by the module Screen.  

The module will be replaced in the next version of the operating system.  It
allows to hide the private exports of the module Screen.   Because of this
indirection, normal users of Screen will not suffer from the intended changes,
the module Screen stays stable 3(Upward compatible)0.

If the module Screen is not used at all, the module DisplayDriver gives cheaper
access to the resident resources used for fonts and bitmaps.
C w15
Restrictions
+
This module will be changed on the next operating system release.

No checks.

Font name of font created with UseFont will not be remembered for
a subsequent call of LoadFont.
C w15
Definition Module
-f7
DEFINITION MODULE ScreenResources0;  (*Ch. Jacobi 10.10.81*)
  FROM SYSTEM IMPORT ADDRESS;
  FROM Screen IMPORT Bitmap, Font;
  EXPORT QUALIFIED PToBMD, PToFontFramePointer, UseBitmap, UseFont;

  (* this module is temporary and will freely be deleted *)

  PROCEDURE PToBMD(b: Bitmap): ADDRESS;
    (* returns pointer to (firmware) bitmapdescriptor;
       however this bitmapdescriptor needs NOT be aligned.
       Do not copy the bitmapdescriptor, a future version of module Screen 
       may move the actual bitmap. Parameter b must not be subbitmap *)
   
  PROCEDURE PToFontFramePointer(f: Font): ADDRESS;
    (* returns pointer to font-framepointer (which ignores 4-word descriptor) 
       Do not copy the font-framepointer, a future version module Screen 
       may move the actual font*)

  PROCEDURE UseBitmap(VAR bm: Bitmap; w,h: CARDINAL;
                      at, size: CARDINAL; VAR done: BOOLEAN);
    (* like CreateBitmap, but uses user specified memory*)
    (* at: (hard)framepointer to bitmap*)

  PROCEDURE UseFont(VAR f: Font; name: ARRAY OF CHAR; 
                    at, size: CARDINAL; VAR done: BOOLEAN);
    (* like LoadFont, but uses user specified memory; no checks*)
    (* at: (hard)framepointer to 4-word soft font descriptor*)

END ScreenResources0.

C
Imported Modules
-f0x25
Screen
Other modules, which are linked with module Screen already.
C w15
Font Format Conventions
+
The microcoded DCH instructions needs a framepointer to denote the 
font.  This framepointer points to the actual font table, which
is a table of offsets (one for each character), followed by the pictures of the
characters. 

The following pseudo declaration should explain the format of the font table
as assumed by the firmware. 
-f7
TYPE ChPointer = SELF-RELATIVE OFFSET TO ChDesc.w;
TYPE ChDesc = RECORD 
                pat: ARRAY [1..height] OF BITSET;
                w:   ONE'S-COMPLEMENT INTEGER; 
                       (* w>=0: width;
                          w <0: -w is index to extend *)
                skip, height: [0..255] (* packed;
                                          skip means empty bottom lines *)
              END;
TYPE fonttable = RECORD
                   chtable: ARRAY [0..255] OF ChPointer;
                   extend:  ARRAY [256..   ] OF ChPointer;
                   characterInfo: ARRAY [..] OF WORD
                 END;
+
On the file and in memory a 4-word header is prefixed to the fonts. This is, however, a software convention only.

This should explain why with PToFontFramePointer a frame pointer is returned, which
points behind the 4-word header, but with UseFont, a frame pointer pointing TO the
4-word header must be given.

4-word header:
-f7x25
length       (16-bit)
checksum     (16-bit)                         1over 4-word header and firm font7
baseline     ( 8-bit) | height   ( 8-bits)
proportional ( 1-bit) | maxwidth (15-bits)    1two's complement7
+
The software allocates also some trailing information in the memory, residing 
after the actual font
table.
C w15
Bitmap Descriptor
+
The following declaration shows the format of bitmap descriptors, as is
assumed by the firmware instructions, and returned by the
procedure PToBMD.  This BitmapDescriptor type is not exported, it 
is for documentation only.  For the old display processor
this type is used also to drive the hardware.
-f7
TYPE  
  BitmapDescriptor =
    RECORD
      bitmapAddress: ADDRESS;  
      width:         CARDINAL;
      heigth:        CARDINAL;
      position:      CARDINAL;
    END;
+Y2
7bitmapAddress:0 is a rotated frame pointer to the memory area used for 
bitmap.  (framepointer rotated 2 bits to left).  Therefore, the two least
significant bits of 7bitmapAddress0 denote the memory bank.

7width:0 Width of the bitmap in words.

7heigth:0 Heigth of the bitmap - 2.  Unit is dots. 

7position:0 Used only in old fashioned display hardware: denotes location
of the displayed bitmap on the screen.  One bit drives inverting the picture.
+f2
Avoid using knowledge of these hardware descriptions. 0Either the hardware
level or the screen software level may be used, but intermixing these levels needs
too much knowledge of implementation details.
p B
10.9.  Lines
+
Christian Jacobi  28.6.82

Library module for drawing straight lines on the screen.
Cf1 Y15
Definition Module
-f7
DEFINITION MODULE Lines;  (* Ch. Jacobi 28.6.82*)
  FROM Screen IMPORT Bitmap, Mode;
  EXPORT QUALIFIED DisplayLine;

  PROCEDURE DisplayLine(VAR bm: Bitmap; ax, ay, bx, by: CARDINAL; m: Mode);

END Lines.
Cf1 Y15
Explanations
+
Procedure 1DisplayLine0 draws a straight line from point 1(ax, ay)0 to
point 1(bx, by)0 on the bitmap 1bm.0  The mode 1m0 is used as in module 
Screen.  

The two end points of the line must lie inside the bitmap; the procedure
may trap otherwise, it does no clipping.  The procedure does not
depend on the order of the two endpoints, if they are 
interchanged, the same line is drawn.
Cf1 Y15
Imported Modules
-f0x25
Screen
