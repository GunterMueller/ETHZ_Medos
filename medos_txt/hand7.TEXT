A c
7.  The Compiler
C Y15 c
Leo Geissmann  15.5.82, rev. 27.9.82
+
This chapter describes the use of the Modula-2 compiler.  For the language definition refer to the Modula-2 manual [1].  Lilith specific language features are mentioned in chapter 12 of this handbook.
B Y20
7.1.  Glossary and Examples
+ w15
1Glossary0
+ x25
2compilation unit0
x50 Y2
Unit accepted by compiler for compilation, i.e. definition module or program module (see Modula-2 syntax in [1]).
+ x25
2definition module0
x50 Y2
Part of a separate module specifying the exported objects.
+ x25
2program module0
x50 Y2
Implementation part of a separate module (called 1implementation module0) or main module.
+ x25
2source file0
x50 Y2
Input file of the compiler, i.e. a compilation unit.  Default extension is 2MOD0.
+ x25
2listing file0
x50 Y2
Compiler output file with list of the compiled unit.  Assigned extension is 2LST0.
+ x25
2symbol file0
x50 Y2
Compiler output file with symbol table information.  This information is generated during compilation of a definition module.  Assigned extension is 2SYM0.
+ x25
2reference file0
x50 Y2
Compiler output file with debugger information, generated during compilation of a program module.  Assigned extension is 2REF0.
+ x25
2object file0
x50 Y2
Compiler output file with the generated M-code in loader format.  Assigned extension is 2OBJ0.
+ w15
1Examples0
+
The examples given in this chapter to explain the compiler execution refer to following compilation units:
= x25
MODULE Prog1;
  ...
END Prog1.

MODULE Prog2;
BEGIN
  a := 2
END PROG2.

DEFINITION MODULE Prog3;
  EXPORT QUALIFIED ...
  ...
END Prog3.

IMPLEMENTATION MODULE Prog3;
  IMPORT Storage;
  ...
END Prog3.
B Y20
7.2.  Compilation of a Program Module
+
The compiler is called by typing 1modula0.  After displaying the string 7source file>0 the compiler is ready to accept the filename of the compilation unit to be compiled.
= x25 t300.
*modula
Modula-2 Compiler C19
 source file> Prog1.MOD         1name DK.Prog1.MOD is accepted7
p1
p2                              1the succession of the activated7
p3                              1compiler passes is indicated7
p4
lister
end compilation
*
+
Default device is 2DK0 and default extension is 2MOD0.

If syntactic errors are detected by the compiler, the compilation is stopped after the third pass and a listing file with error messages is generated.
= x25 t300.
 source file> Prog2.MOD
p1
 ---- error                      1error detected by pass17
p2
p3
 ---- error                      1error detected by pass37
lister
end compilation
B Y20
7.3.  Compilation of a Definition Module
+
For definition modules the filename extension 2DEF0 is recommended.  The definition part of a module must be compiled 1prior0 to its implementation part.  A symbol file is generated for definition modules.
= x25 t300.
 source file> Prog3.DEF          1definition module7
p1
p2
symfile
lister
end compilation
B Y20
7.4.  Symbol Files Needed for Compilation
+
Upon compilation of a definition module, a symbol file containing symbol table information  is generated.  This information is needed by the compiler in two cases:
x25
At compilation of the implementation part of the module.

At compilation of another unit, importing objects from this separate module.
+
According to a program option, set when the compilation is started (see chapter 7.6.), the compiler either explicitly prompts for the names of the needed symbol files, or searches for a needed symbol file (extension 2SYM0) by a default name, which is constructed from (the first 16 characters of) the module name.  In the former case the query for a symbol file is repeated until an adequate file is found or the 2ESC0 key is typed.  If in the latter case the search fails, the default name is combined with a prefix 2LIB0 and the compiler tries again to find a corresponding file.  A second failure would cause an error message.
x25 t210.
Module name  7Storage0
First file name  7DK.Storage.SYM0
Second file name  7DK.LIB.Storage.SYM0
+
If not all needed symbol files are available, the compilation process is stopped immediately.
= x25 t300.
 source file> Prog3.MOD          1implementation module7
p1
 Prog3: DK.Prog3.SYM
 Storage: DK.LIB.Storage.SYM
p2
p3
p4
lister
end compilation
B Y20
7.5.  Compiler Output Files
+
Several files are generated by the compiler.  They get the same file name as the source file with an extension changed as follows
x25 n
7LST0   listing file
7SYM0   symbol file
7REF0   reference file
7OBJ0   object file
+
The reference file may be used by a debugger to obtain names of objects.
B Y20
7.6.  Program Options for the Compiler
+
When reading the source file name, the compiler also accepts some program options from the keyboard.  Program options are marked with a leading character 2/0 and must be typed sequentially after the file name (see chapter 4.).

The compiler accepts the option values:
+ x25
2LISTing0
x50 Y2
A listing file must be generated.  1Default0.
+ x25
2Nolisting0
x50 Y2
No listing file must be generated.
+ x25
2Query0
x50 Y2
the compiler explicitly prompts for the names of the needed symbol files, belonging to modules imported by the compiled unit.
+ x25
2NOQuery0
x50 Y2
No query for symbol file names.  Files are searched corresponding to a default strategy.  1Default0.
+ x25
2SMall0
x50 Y2
A small program is compiled.  Work files of the compiler may be allocated in memory.  1Default0.
+ x25
2LArge0
x50 Y2
A large program is compiled.  Work files of the compiler must be allocated on the disk.
+ x25
2Version0
x50 Y2
Compiler has to display information about the running version, e.g. processor and operating system flags.
+
Capitals mark the abbreviations of the option values.
B Y20
7.7.  Compilation Options in Compilation Units
+
Comments in a Modula-2 compilation unit may be used to specify certain 1compilation options0 for tests.

The following syntax is accepted for compilation options:
- x25 t170.
CompOptions  =  CompOption { "," CompOption } .
CompOption   =  "$" Letter Switch .
Switch   =  "+" | "-" | "=" .
+
Compilation options must be the first information within a comment.  They are not recognized by the compiler, if other information precedes the options.
+ x25 w15
1Letter0
Y2 n
7R0    Subrange and type conversion test.
7T0    Index test (arrays, case).
+ x25 w15
1Switch0
Y2 n
7+0    Test code is generated.
7-0    No test code is generated.
7=0    Previous switch becomes valid again.
+
All switches are set to 7+0 by default.
= x25 t300.
MODULE x; (* $T+ *)
  ...                            1test code generated7
  (* $T- *)
  a[i] := a[i+1];                1no test code is generated7
  (* $T= *)
  ...                            1test code is generated7
END x
B Y20
7.8.  Module Key
+
With each compilation unit the compiler generates a so called 1module key0.  This key is unique and is needed to distinguish different compiled versions of the same module.  The module key is written on the symbol file and on the object file.

For an implementation module the key of the associated definition module is adopted.  The module keys of imported modules are also recorded on the generated symbol files and the object files.

Any mismatch of module keys belonging to the same module will cause an error message at compilation or loading time.
x25 B c
W A R N I N G
+ x25
Recompilation of a definition module will produce a 1new0 symbol file with a 1new module key0.  In this case the implementation module and all units importing this module must be 1recompiled0 as well.

Recompilation of an implementation module does not affect the module key.
B Y20
7.9.  Program Execution
+
Programs are normally executed on the top of the resident operating system 1Medos-20.  The 1command interpreter0 accepts a program name and causes the 1loader0 to load the module on the corresponding object file into the memory and to start its execution.

If a program consists of several separate modules, no explicit linking is necessary.  The object files generated by the compiler are merely ready to be loaded.  Besides of the 1main module0, the module which is called to be executed and therefore constitutes the main program, all modules which are directly or indirectly imported are loaded.  The loader establishes the links between the modules and organizes the initialization of the loaded modules.

Usually some of the imported modules are part of the already loaded, resident Medos-2 system (e.g. module FileSystem).  In this case the loader sets up the links to these modules, but prohibits their reinitialization.  A module cannot be loaded twice.

After termination of the program, all separate modules which have been loaded together with the main module are removed from the memory.  More details concerning program execution are given in chapter 3.

Although it is not necessary to link programs explicitly, it is sometimes more appropriate to 1previously0 collect all modules, which are to be loaded together, and to write them on the same file.  This will accelerate the loading.  Linking is provided by the program 1link0 (see chapter 6.7.).

Medos-2 also supports some kind of a 1program stack0.  A program may call another program, which will be executed on the top of the calling program.  After termination of the called program, control will be returned to the calling program.  For more details refer to the library module 1Program0 (see chapter 9.2.).
B Y20
7.10.  Value Ranges of the Standard Types
+
The value ranges of the Modula-2 standard types on Lilith are defined according to the word size of 16 bit.
+ x25
7INTEGER0
x50 Y2
The value range of type 7INTEGER0 is 7[-32768..32767]0.  Sign inversion is an operation within constant expressions.  Therefore the compiler does not allow the direct definition of 7-327680.  This value must be computed indirectly, e.g. 7-32767-10.
+ x25
7CARDINAL0
x50 Y2
The value range of type 7CARDINAL0 is 7[0..65535]0. 
+ x25
7REAL0
x50 Y2
Values of type 7REAL0 are represented in 2 words.  The value range expands from 7-1.7014E380 to 71.7014E380.
+ x25
7CHAR0
x50 Y2
The character set of type 7CHAR0 is defined according to the ISO - ASCII standard with ordinal values in the range 7[0..255]0.  The compiler processes character constants in the range 7[0C..377C]0.
+ x25
7BITSET0
x50 Y2
The type 7BITSET0 is defined as 7SET OF [0..15]0.  Consider that sets are represented from the high order bits to the low order bits, i.e. 7{15}0 corresponds to the ordinal value 710.
B Y20
7.11.  Differences and Restrictions
+
For the implementation of Modula-2 on Lilith some differences and restrictions must be considered.
+ x25
2Constants expressions with real numbers0
x50 Y2
Constants expressions with real numbers are 1not0 evaluated by the compiler (except sign inversion).  The compiler generates an error message.
+ x25
2Character arrays0
x50 Y2
In arrays with element type 7CHAR0 two characters are packed into one word.  This implies the restriction that a variable parameter of type 7CHAR0 1must not0 be substituted by an element of a character array.
p + x25
2Sets0
x50 Y2
Maximal ordinal value for set elements is 7150.
+ x25
2FOR statement0
x50 Y2
The values of both expressions of the for statement must not be greater than 7327670 (777777B0).  The values are checked at run time, if the compilation option 2R+0 is specified.  The step must be within the range 7[-128..127]0, except the value 700.
+ x25
2CASE statement0
x50 Y2
The labels of a case statement must not be greater than 7327670 (777777B0).
+ x25
2Value ARRAY OF WORD parameter0
x50 Y2
Constants (with the exception of constant strings) must not be substituted for a value dynamic 7ARRAY OF WORD0 parameter.
+ x25
2Function procedures0
x50 Y2
The 1result type0 of a function procedure must neither be a record nor an array.
p B
7.12.  Compiler Error Messages
- x25 t100.
  0   :  illegal character in source file
  1   :
  2   :  constant out of range
  3   :  open comment at end of file
  4   :  string terminator not on this line
  5   :  too many errors
  6   :  string too long
  7   :  too many identifiers (identifier table full)
  8   :  too many identifiers (hash table full)
 
 20   :  identifier expected
 21   :  integer constant expected
 22   :  ']' expected
 23   :  ';' expected
 24   :  block name at the END does not match
 25   :  error in block
 26   :  ':=' expected
 27   :  error in expression
 28   :  THEN expected
 29   :  error in LOOP statement
 30   :  constant must not be CARDINAL
 31   :  error in REPEAT statement
 32   :  UNTIL expected
 33   :  error in WHILE statement
 34   :  DO expected
 35   :  error in CASE statement
 36   :  OF expected
 37   :  ':' expected
 38   :  BEGIN expected
 39   :  error in WITH statement
 40   :  END expected
 41   :  ')' expected
 42   :  error in constant
 43   :  '=' expected
 44   :  error in TYPE declaration
 45   :  '(' expected
 46   :  MODULE expected
 47   :  QUALIFIED expected
 48   :  error in factor
 49   :  error in simple type
 50   :  ',' expected
 51   :  error in formal type
 52   :  error in statement sequence
 53   :  '.' expected
 54   :  export at global level not allowed
 55   :  body in definition module not allowed
 56   :  TO expected
 57   :  nested module in definition module not allowed
 58   :  '}' expected
 59   :  '..' expected
 60   :  error in FOR statement
 61   :  IMPORT expected
 
 70   :  identifier specified twice in importlist
 71   :  identifier not exported from qualifying module
 72   :  identifier declared twice
 73   :  identifier not declared
 74   :  type not declared
 75   :  identifier already declared in module environment
 76   :
 77   :  too many nesting levels
 78   :  value of absolute address must be of type CARDINAL
 79   :  scope table overflow in compiler
 80   :  illegal priority
 81   :  definition module belonging to implementation not found
 82   :  structure not allowed for implementation of hidden type
 83   :  procedure implementation different from definition
 84   :  not all defined procedures or hidden types implemented
 85   :  name conflict of exported object or enumeration constant in environment
 86   :  incompatible versions of symbolic modules
 87   :
 88   :  function type is not scalar or basic type
 89   :
 90   :  pointer-referenced type not declared
 91   :  tagfieldtype expected
 92   :  incompatible type of variant-constant
 93   :  constant used twice
 94   :  arithmetic error in evaluation of constant expression
 95   :  incorrect range
 96   :  range only with scalar types
 97   :  type-incompatible constructor element
 98   :  element value out of bounds 
 99   :  set-type identifier expected
100   :  structured type too large
101   :  undeclared identifier in export list of the module
102   :  range not belonging to base type
103   :  wrong class of identifier 
104   :  no such module name found 
105   :  module name expected
106   :
107   :  set too large 
108   :
109   :  scalar or subrange type expected
110   :  case label out of bounds 
111   :  illegal export from program module
112   :  code block for modules not allowed
 
120   :  incompatible types in conversion
121   :  this type is not expected
122   :  variable expected
123   :  incorrect constant
124   :  no procedure found for substitution
125   :  unsatisfying parameters of substituted procedure
126   :  set constant out of range 
127   :  error in standard procedure parameters 
128   :  type incompatibility 
129   :  type identifier expected
130   :  type impossible to index 
131   :  field not belonging to a record variable 
132   :  too many parameters 
133   :  
134   :  reference not to a variable
135   :  illegal parameter substitution 
136   :  constant expected
137   :  expected parameters
138   :  BOOLEAN type expected
139   :  scalar types expected
140   :  operation with incompatible type 
141   :  only global procedure or function allowed in expression
142   :  incompatible element type 
143   :  type incompatible operands
144   :  no selectors allowed for procedures
145   :  only function call allowed in expression
146   :  arrow not belonging to a pointer variable 
147   :  standard function or procedure must not be assigned
148   :  constant not allowed as variant 
149   :  SET type expected 
150   :  illegal substitution to WORD parameter
151   :  EXIT only in LOOP 
152   :  RETURN only in PROCEDURE
153   :  expression expected 
154   :  expression not allowed
155   :  type of function expected 
156   :  integer constant expected 
157   :  procedure call expected
158   :  identifier not exported from qualifying module
159   :  code buffer overflow
160   :  illegal value for code
161   :  call of procedure with lower priority not allowed
 
200   :  compiler error
201   :  implementation restriction
202   :  implementation restriction: for step too large
203   :  implementation restriction: boolean expression too long
204   :  implementation restriction: expression stack overflow,
         i.e. expression too complicated or too many parameters
205   :  implementation restriction: procedure too long
206   :  implementation restriction: packed element used for var parameter
207   :  implementation restriction: illegal type conversion
 
220   :  not further specified error
221   :  division by zero
222   :  index out of range or conversion error
223   :  case label defined twice
