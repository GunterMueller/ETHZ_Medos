(*********************************
*                                *
*                                *
*           XREF                 *
*                                *
*     UTILITY PROGRAM            *
*     written by                 *
*     STEFAN BERNER              *
*                                *
*     Diplomarbeit am            *
*     Institut fuer Informatik   *
*     ETH Zuerich                *
*     CH-8092 ZUERICH            *
*                                *
*                                *
*                                *
*    ( NOV/DEC 78 )              *
*    Modifications Naegeli:      *
*      17.04.79                  *
*    Modifications Geissmann:    *
*      18.12.79                  *
*      23.05.80                  *
*      16.10.80 for Lilith       *
*                                *
*                                *
********************************** 



SUMMARY
-------
   The program XREF generates from an input-ascii-file
   a cross reference list and a listing with numbered
   lines. XREF is written in MODULA-2 (version 2.10) and
   was implemented on PDP 11/30 under RT-11.


 
main features
-------------

1) the program demand one inputfile    : file.ext
2) two ascii-outputfiles are generated : file.LST
                                         file.XRF
3) this two files are already formated and may be
   printed directly to the lineprinter
4) when the inputfile is a list-file (with numbered lines),
   no listing will be generated by CROSSREF and the linenumbers
   are taken as referencenumbers ( lines without linenumbers
   (e.g. error-lines) are skipped )
5) three switches may be set : /E,/S and /list
   /S            : a small statistic will be printed to the keyboard
   /E            : the file .XRF contains 12 referencenumbers
                   per line (default : /E missing => 12 numbers per line)
   /list   : list may be N or L:
            /L    : generate a listfile (in any case)    
            /N    : inputfile is a listfile (with numbered lines)
        default   : if the first nonblank at the first nonempty line
                    of the file input is a digit, the inputfile is
                    treated as listfile otherwise, as a textfile
                    (e.g. .MOD) ( see 4 )

6) identifiers can have at most a length of 40 characters;
   only 20 characters will be printed in the xreftable
 
 
7) CROSSREF makes a difference between small an capital letters
   priority : 1 lexicografical order
              2 small letter < capital letter




 
MODULA-2 dependent features
--------------------------- 

- keywords of MODULA-2 are not listed in the xreftable 
- B and C at the end of a number are not treated as identifiers
- comments (**) are skipped (also nested comments!)
- strings ( '  ', "  ") are skipped

*)

(************************************************************)

MODULE XREF;  (*$T-*)

  IMPORT
    SYSTEM, FileSystem, FileNames, Options,
    Terminal, Conversions;

MODULE KeyDefinition;

(* Define all key-words, which are not listed in the cross-
   reference-table. Standard identifiers are NOT keywords!        *)
   
EXPORT QUALIFIED keynum, key;
 
 
CONST keynum = 41;                  (* Number of keywords *)
      alfalength = 14;

TYPE  alfa = ARRAY [0..alfalength] OF CHAR;       

VAR   key :  ARRAY [1..keynum] OF alfa;
      keyix : CARDINAL;

  PROCEDURE InsertKey(keystring: alfa);
  BEGIN
    INC(keyix);
    IF keyix > keynum THEN HALT END;
    key[keyix] := keystring;
  END InsertKey;


BEGIN
  keyix := 0;
  InsertKey("AND ");
  InsertKey("ARRAY ");
  InsertKey("BEGIN ");
  InsertKey("BY ");
  InsertKey("CASE ");
  InsertKey("CODE ");
  InsertKey("CONST ");
  InsertKey("DEFINITION ");
  InsertKey("DIV ");
  InsertKey("DO ");
  InsertKey("ELSE ");
  InsertKey("ELSIF ");
  InsertKey("END ");
  InsertKey("EXIT ");
  InsertKey("EXPORT ");
  InsertKey("FOR ");
  InsertKey("FROM ");
  InsertKey("IF ");
  InsertKey("IMPLEMENTATION ");
  InsertKey("IMPORT ");
  InsertKey("IN ");
  InsertKey("LOOP ");
  InsertKey("MOD ");
  InsertKey("MODULE ");
  InsertKey("NOT ");
  InsertKey("OF ");
  InsertKey("OR ");
  InsertKey("POINTER ");
  InsertKey("PROCEDURE ");
  InsertKey("QUALIFIED ");
  InsertKey("RECORD ");
  InsertKey("REPEAT ");
  InsertKey("RETURN ");
  InsertKey("SET ");
  InsertKey("THEN ");
  InsertKey("TO ");
  InsertKey("TYPE ");
  InsertKey("UNTIL ");
  InsertKey("VAR ");
  InsertKey("WHILE ");
  InsertKey("WITH ");
  IF keyix <> keynum THEN HALT END;
END KeyDefinition;


(**************************************************)


MODULE Scanner;

FROM KeyDefinition IMPORT keynum, key;       
FROM TableHandler  IMPORT Enter;   
FROM FileSystem    IMPORT Reset;
FROM InputOutput   IMPORT
  WriteCh,ReadCh,eolc,WriteNum,input,output,ERROR;

EXPORT QUALIFIED  Scan,id,first,last;

CONST  maxid=39; (* max length of identifier *)

VAR  id  : ARRAY [0..maxid] OF CHAR;
     first,last : CARDINAL; (* first and last linenumber *)

   
   PROCEDURE Scan(VAR switch : CARDINAL);
   (* scan the input text and generate the xreftable and the listing *)

   VAR     ch        : CHAR;
           i,k,l,m,r : CARDINAL;  (* auxiliary *)
           lno       : CARDINAL;  (* linenumber *)
           listing   : BOOLEAN;   (* listing ==> generate listing *)
 
   
      PROCEDURE Copy;
      BEGIN
         IF listing THEN WriteCh(ch) END;
         ReadCh(ch);
      END Copy;

   (*-----*)

      PROCEDURE NewLine;
      BEGIN
        IF listing THEN
           INC(lno);
           WriteNum(lno,6);
           WriteCh(' ');WriteCh(' ')
        ELSE
           (* skip empty lines and get first nonblank*)
           WHILE (ch = ' ') AND NOT input.eof DO
             ReadCh(ch);
           END;
           IF (ch>='0') & (ch<='9') AND NOT input.eof THEN
             lno:=ReadCARDINAL()
           ELSE 
             (*skip unnumbered lines *)
             WHILE (ch <> eolc) AND NOT input.eof DO ReadCh(ch) END;
             IF NOT input.eof THEN ReadCh(ch); NewLine END;
           END (* IF *)
        END; (* IF *)
        IF first = 0 THEN first := lno END
      END NewLine;

   (*-----*)

      PROCEDURE ReadCARDINAL():CARDINAL;
      VAR x : CARDINAL;
          b : BOOLEAN;

      BEGIN
         x:=0; b := TRUE;
         WHILE (ch >= '0') AND (ch <= '9') AND NOT input.eof DO
            IF x > 3275 THEN IF b THEN ERROR(8) END;
                             b := FALSE; x:=3275
            END;
            x:=10*x+CARDINAL(ch)-CARDINAL('0');
            ReadCh(ch)
         END;
         RETURN x
      END ReadCARDINAL;

   (*-----*)

      PROCEDURE Comment;
      (* recursive procedure for nested comments *)

      BEGIN
        LOOP
          IF input.eof THEN EXIT END;
          IF ch='(' THEN
            Copy;
            IF (ch='*') AND NOT input.eof THEN Copy; Comment END;
          ELSIF ch=eolc THEN
            Copy;
            IF NOT input.eof THEN NewLine END;
          ELSIF ch = '*' THEN
            Copy;
            IF (ch = ')') AND NOT input.eof THEN Copy; EXIT END
          ELSE Copy
          END; (* IF *)
        END; (* LOOP *)
      END Comment;

   (*-----*)


   BEGIN  (* Scan *)
     lno:=0;
     first := 0;
     listing := (switch = 0);
     IF switch = 2 THEN
       REPEAT
         ReadCh(ch);
         IF (ch = eolc) AND NOT input.eof THEN
           ReadCh(ch);
         END
       UNTIL (ch # " ") OR input.eof;
       listing:=(ch<'0') OR (ch>'9');
       Reset(input)
     END; (* IF *)
     IF listing THEN switch := 1
                ELSE switch := 0
     END;
     (* start to scan *)
     ReadCh(ch);
     WHILE NOT input.eof DO
        NewLine;
        WHILE (ch <> eolc) AND NOT input.eof DO
          IF (CAP(ch) >= 'A') AND (CAP(ch) <= 'Z') THEN  (* identifier *)
            k:=0;           
            REPEAT
              IF k < maxid THEN id[k]:=ch; INC(k) END;
              Copy
            UNTIL ((ch<'0')OR(ch>'9'))AND((CAP(ch)<'A')OR(CAP(ch)>'Z'))
                  OR input.eof;
            l:=1; r:=keynum;
            id[k]:=" ";
            (* binary search *)
            REPEAT
              m:= (l+r) DIV 2;
              i:=0;
              WHILE (id[i]=key[m,i]) & (id[i]#" ") DO INC(i) END;
              IF id[i] <= key[m,i] THEN r:=m-1 END;
              IF id[i] >= key[m,i] THEN l:=m+1 END 
             UNTIL l>r;
             IF l=r+1 THEN Enter(lno) END  (* no keyword, hence insert lno *)
           ELSIF (ch>='0') & (ch<='9') THEN   (* number *)
             REPEAT Copy UNTIL ((ch<'0') OR (ch>'9')) AND
                               ((CAP(ch)<'A') OR (CAP(ch)>'F')) OR
                               input.eof;
             IF NOT input.eof THEN
               IF CAP(ch) = 'H' THEN Copy;
               ELSIF ch = '.' THEN (* real number *)
                 Copy;
                 WHILE (ch>='0') AND (ch<='9') AND NOT input.eof DO
                   Copy;
                 END;
                 IF (CAP(ch) = 'E') AND NOT input.eof THEN
                   Copy;
                   IF ((ch='+') OR (ch='-')) AND NOT input.eof THEN
                     Copy;
                   END;
                   WHILE (ch>='0') AND (ch<='9') AND NOT input.eof DO
                     Copy;
                   END;
                 END;
               END;
             END;
           ELSIF ch='(' THEN
             Copy;
             IF (ch='*') AND NOT input.eof THEN Copy; Comment END;
           ELSIF ch='"' THEN   (* string *)
             REPEAT Copy UNTIL (ch='"') OR input.eof;
             Copy
           ELSIF ch="'" THEN   (* string *)
             REPEAT Copy UNTIL (ch="'") OR input.eof;
             Copy
           ELSIF ch # eolc THEN Copy
           END; (* IF *)
         END; (* WHILE *)
         IF NOT input.eof THEN Copy END;
     END;  (*WHILE*)
     last:=lno
   END Scan;
END Scanner;




(**************************************************************)
   
   
   
MODULE InputOutput;


FROM FileSystem   IMPORT File, ReadChar, WriteChar, ReadWord, WriteWord;
FROM Terminal     IMPORT WriteString, WriteLn;
IMPORT SYSTEM;

EXPORT QUALIFIED
  WriteCh,ReadCh,WriteNum,WriteBlanks,Writeln,
  eolc, input,output,ERROR,
  wordfile,PutWord,GetWord,eorf,fileref,BlockMark,TreeFlag;

CONST  eolc = 36C;     (* line separator *)

TYPE String30 = ARRAY [0..29] OF CHAR;
 
 
VAR    input,output : File;

(**********)

   MODULE RefFile;
   (* This MODULE defines the 4 local files ref1 - ref4
      and contains the operations for them     *)

   FROM SYSTEM IMPORT WORD;
   IMPORT File, ReadWord, WriteWord;

   EXPORT wordfile,PutWord,GetWord,eorf,fileref,BlockMark,TreeFlag;

   CONST BlockMark = 177777B;
         TreeFlag = 100000B; 

   TYPE wordfile = RECORD
                    file : File;
                    cnt  : CARDINAL
                   END;

   VAR fileref : ARRAY [1..4] OF wordfile;

   PROCEDURE GetWord(rf:CARDINAL;VAR w:WORD);
   BEGIN
      WITH fileref[rf] DO
         ReadWord(file,w);
         DEC(cnt)
      END (* WITH *)
   END GetWord;

   (*---*)

   PROCEDURE PutWord(rf:CARDINAL; w:WORD);
   BEGIN
      WITH fileref[rf] DO
         WriteWord(file,w);
         INC(cnt)
      END (* WHILE *)
   END PutWord;

   (*---*)

   PROCEDURE eorf(rf:CARDINAL):BOOLEAN;
   (* end-of-ref-file *)

   BEGIN RETURN fileref[rf].cnt<=0
   END eorf;

   END RefFile;

(**********)



PROCEDURE ReadCh(VAR ch : CHAR);
(* Read one character from file input *)

BEGIN
   ReadChar(input,ch)
END ReadCh;

(*-----*)
 

PROCEDURE WriteCh(ch : CHAR);
(* Write one character to the file output *)

BEGIN
   WriteChar(output,ch)
END WriteCh;

(*-----*)
 

PROCEDURE WriteNum(x: INTEGER;n: CARDINAL);
(* Write x in decimal form with n characters to file f *)

VAR  i     : CARDINAL;
     x1,x2 : INTEGER;
     d     : ARRAY [1..6] OF CHAR;  (* x in character-form;assume log10(x)<7 *)

BEGIN
   x1:=ABS(x);
   i:=0;
   REPEAT
      INC(i);
      x2:=x1 DIV 10;
      d[i]:=CHAR(x1-x2*10+60B);  (* =CHAR(x1 MOD 10 + INTEGER('0') *)
      x1:=x2
   UNTIL x1=0;
   IF x < 0 THEN INC(i); d[i]:='-' END;
   WHILE n>i DO WriteChar(output," "); DEC(n)  END;
   REPEAT 
      WriteChar(output,d[i]); DEC(i)
   UNTIL i=0;
END WriteNum;

(*-----*)


PROCEDURE Writeln;

BEGIN
   WriteChar(output,eolc);
END Writeln;

(*-----*)

PROCEDURE WriteBlanks(n: CARDINAL);

BEGIN
   WHILE n > 0 DO
      WriteChar(output," ");
      DEC(n)
   END (* WHILE *)
END WriteBlanks;

(*-----*)

PROCEDURE ERROR(n:CARDINAL);

BEGIN
  WriteString(" ---- ");
  CASE n OF
   1  : WriteString('DEVICE FULL');
  |2  : WriteString('TOO MANY IDENTIFIERS');
  |3  : WriteString('TOO MANY CHARACTERS');
  |4  : WriteString('BYE');
  |5  : WriteString('ILL SWITCH')
  |6  : WriteString('ILL COMMAND')
  |7  : WriteString('FILE NOT FOUND')
  |8  : WriteString('LINENUMBER TO LARGE')
  END; (* CASE *)
  WriteLn;
END ERROR;

(*-----*)

 
END InputOutput;

(**************************************************)

MODULE TableHandler;

FROM Scanner        IMPORT id,first,last;
FROM RefListOut     IMPORT OutRef,InvertOrder;
FROM InputOutput    IMPORT
  Writeln,WriteNum,WriteCh,WriteBlanks,output,ERROR,
  GetWord,BlockMark,TreeFlag;
FROM Command        IMPORT reffileout;

EXPORT QUALIFIED Enter,root,treearr,refarr,refind,WriteTab,chlst,treelog,
                 chind,treeind;

CONST  maxchar   = 6000; (* size of CHAR-ARRAY      (ca 3000 words)*)
       maxreftab = 4000; (* size of Reference table (ca 8000 words)*)
       maxtree   =  800; (* size of tree ARRAY      (ca 3200 words)*)
       treelog   =   30; (* must be greater than  (2 * log2(maxtree)) *)
   
   MODULE CharacterTable;
   (* This Module contains all tables, index' and procedures for the
      identifierlist. *)
   
   
   IMPORT id,maxchar;
    
   EXPORT  chlst,chind,Compare,relation,InsertId;
   
   
   TYPE  relation = (less,equal,greater);
   
   VAR   chlst  : ARRAY [0..maxchar] OF CHAR; (* character-list *)
         chind  : CARDINAL;  (* index to first free place at chlst *)
   
   
   PROCEDURE Compare(k:CARDINAL):relation;
   (* Compare id with the identifier beginning at chlst[k] and returns
      less,equal or greater *)
   
   VAR i : CARDINAL;
       ch: CHAR;   
       r : relation;

   BEGIN
      i:=0;
      LOOP
         ch:=id[i];
         IF ch # chlst[k] THEN EXIT END;
         IF ch <=  " " THEN RETURN equal END;
         INC(i);INC(k)
      END;  (* LOOP *)
      IF CAP(ch) > CAP(chlst[k])    THEN RETURN greater
      ELSIF CAP(ch) < CAP(chlst[k]) THEN RETURN less
      ELSE (* same letters  (capital & small) *)
         (* assume upper case letter greater than lower case letter *)
         IF ch < chlst[k] THEN r:=greater
                          ELSE r:=less END;
         LOOP
            IF CAP(ch) # CAP(chlst[k]) THEN EXIT END;
            IF (ch <= ' ') AND (chlst[k] <= ' ') THEN RETURN r END;
            INC(i);INC(k);
            ch:=id[i]
         END; (* LOOP *)
         IF CAP(ch) > CAP(chlst[k]) THEN RETURN greater
                                    ELSE RETURN less END
      END  (* IF *)
   END Compare;
    
   (*-----*)
    
   PROCEDURE InsertId(VAR err : BOOLEAN);
   (* Insert id in chlst beginning at chind. 1 blank is added.
      chind is the adress of the next free place on chlst.
      err = TRUE  <=== no place in chlst *)
   
   
   VAR i : CARDINAL;
   
   BEGIN
      err:=FALSE;
      i:=0;
      WHILE (id[i] > " ") & NOT  err DO
         chlst[chind]:=id[i];
         IF chind = maxchar THEN err:= TRUE
                            ELSE INC(i);INC(chind)
         END (* IF *)
      END; (* WHILE *)
      chlst[chind]:=" ";
      IF chind = maxchar THEN err:=TRUE
                         ELSE INC(chind)  END 
   END InsertId;
   
   
   (*-----*)
   
   
   BEGIN
      chind:=0
   END CharacterTable;
   
   
   (***********************************)
   
   
   
   MODULE ReferenceTable;
   (* contain all variables and procedures for the handling
      of the referencelist                                 *)
   
   IMPORT maxreftab;

   EXPORT refarr,refind,InsertRf;
   
    
   
   TYPE  ref = RECORD 
               rnum,next : CARDINAL
               END;
   
   VAR   refarr  : ARRAY [1..maxreftab] OF ref; (*reference numbers array *)
         refind  : CARDINAL;   (* pointer to first element of LAVS *)
   
   
   PROCEDURE InsertRf(VAR ind:CARDINAL;num:CARDINAL;VAR reffull:BOOLEAN);
   
   VAR p: CARDINAL;
   
   BEGIN
      p:=refind;
      refind:=refarr[refind].next;
      IF refind = 0 THEN reffull := TRUE END;
      WITH refarr[p] DO
         rnum:=num;
         next:=ind
      END; (* WITH *)
      ind:=p;
   END InsertRf;         
   
   
   
   BEGIN
   (* initialise LAVS *)
      FOR refind:= 1 TO (maxreftab-1) DO  refarr[refind].next:= refind+1 END;
      refarr[maxreftab].next:=0;
      refind:=1
   END ReferenceTable;
   
   
   (************************************)
   
   
   
   MODULE Tree;
   (* contains all variables and procedures for the treehandling *)
   
   IMPORT
     OutRef,reffileout,InsertRf,Compare,relation,InsertId,
     chind,ERROR,maxtree;

   
   EXPORT Enter,root,treearr,treeind;
    
   
   CONST  root = 0     ; (* root of tree *)
   
   
   TYPE   pointrec = RECORD
                       pid,pref  : CARDINAL; (* pointers to char- and reflist *)
                       pgreater,pless : CARDINAL
                     END;
   
   VAR   treearr  : ARRAY [0..maxtree] OF pointrec;  (* tree-array *)
         treeind  : CARDINAL;   (* pointer to last used element *)
         full     : CARDINAL;   (* table full *)
         refful   : BOOLEAN;    (* referencelist full *)
   
   
   
   PROCEDURE Enter(num :CARDINAL);
   (* IF id in list THEN insert refnum
                    ELSE insert id and refnum
      full = 1   : tree-array full;
           = 2   : char-array full;
   *)
   
   VAR p      : CARDINAL;

   
      PROCEDURE Search(p:CARDINAL):CARDINAL;
      (* search id. IF not found, insert a new element in tree and id in the
         char-list. Return the adress of the created or found element *)
       
      VAR  q : CARDINAL;
           r : relation;
           err : BOOLEAN;
    
      BEGIN
         q:=treearr[p].pgreater; r:=greater;
         WHILE q # 0 DO
            p:=q;
            WITH treearr[p] DO
               r:=Compare(pid);
               IF r = equal THEN RETURN p    
               ELSIF r=less THEN q:=pless
                            ELSE q:=pgreater
               END  (* IF *)
            END  (* WITH *)
         END;  (* WHILE *)
         (* NOT found, hence insert *)
         IF treeind = maxtree THEN full:=1
         ELSE
            INC(treeind);
            IF r = greater THEN treearr[p].pgreater:=treeind
                           ELSE treearr[p].pless := treeind
            END;  (* IF *)
            WITH treearr[treeind] DO
               pgreater:=0;
               pless:=0;
               pid:=chind;
               pref:=0 
            END;  (* WITH *)
            InsertId(err);
            IF err THEN full :=2 END
         END; (* IF *)
         RETURN treeind
      END Search;
   
   
   
   BEGIN  (* Enter *)
      p:=Search(root);
      CASE full OF
      1 : ERROR(2)(* TREE-LIST FULL *)
     |2 : ERROR(3)(* CHAR-LIST FULL *)
      ELSE END; (* CASE *)
      InsertRf(treearr[p].pref,num,refful);
      IF refful THEN OutRef; refful:=FALSE; reffileout:=TRUE  END;
   END Enter;
   
   
   BEGIN
      refful:=FALSE;
      full:=0;
      treeind:=0;
      WITH treearr[root] DO
       pgreater := 0; pless := 0; pid := 0; pref := 0;
      END;
   END Tree;
   
   (***********************************)
      
   
   PROCEDURE WriteTab(onfile : BOOLEAN; tab,N : CARDINAL);
   (* write the whole X-ref-list (with identifiers ) to the 
      file output   
      onfile = TRUE ===> part of the reference-list is on the file tab
      The list in the reference-array is in reversed order!      *)
   
   
   TYPE str = ARRAY [0..12] OF CHAR;

   VAR  w  : CARDINAL;
    
      PROCEDURE Print(p:CARDINAL);
      (* Print out the node p (identifier and reference-list *)
   
      CONST L = 20;  (* max length of identifier *)
   
      VAR  i,k : CARDINAL;
   
          
      BEGIN
         (* print identifier *)
         i:=treearr[p].pid;
         k:=L;
         REPEAT 
            WriteCh(chlst[i]);
            INC(i);DEC(k) 
         UNTIL (chlst[i]=" ") OR (k<=0);
         WriteBlanks(k);
         i:=N;
         IF onfile THEN
            IF p=w-TreeFlag THEN
               (* write out the first references: they are on the file *)
               GetWord(tab,w);
               REPEAT
                  IF i=0 THEN Writeln;WriteBlanks(L);
                              i:=N
                  END; (* IF *)
                  WriteNum(w,6); INC(refind);
                  GetWord(tab,w);
                  DEC(i)
               UNTIL w >= TreeFlag;
            END; (* IF *)
            onfile:= (w # BlockMark);
         END; (* IF *)
         p:=treearr[p].pref;
         (* write out the last references: they are in core *)
         IF p#0 THEN
            InvertOrder(p);
            REPEAT
               IF i=0 THEN Writeln;WriteBlanks(L);
                        i:=N
               END; (* IF *)
               WriteNum(refarr[p].rnum,6); INC(refind);
               p:=refarr[p].next;
               DEC(i)
            UNTIL p=0 
         END; (* IF *)
         Writeln;
      END Print;
   
      (*-----*)
   
      PROCEDURE TraverseTree(p:CARDINAL);
      BEGIN
         IF p#0 THEN
            TraverseTree(treearr[p].pless);
            Print(p);
            TraverseTree(treearr[p].pgreater)
         END (* IF *)
      END TraverseTree;
   
      (*-----*)

      PROCEDURE firstlast(mes : str;fila : CARDINAL);
      VAR i : CARDINAL;
      BEGIN
         FOR i := 0 TO 12 DO WriteCh(mes[i]) END;
         WriteNum(fila,6);
         Writeln
      END firstlast;

      (*-----*)
   
   
   BEGIN  (* WriteTab *)
      refind:=0;
      Writeln;
      firstlast('FIRST LINE = ',first);
      firstlast('LAST LINE  = ',last);
      Writeln;
      IF onfile THEN GetWord(tab,w) END;
      Writeln;
      TraverseTree(treearr[root].pgreater);
      Writeln;
   END WriteTab;


END TableHandler;


(**************************************************)
 
 
 
MODULE RefListOut;
(* contains all variables and procedures to write the referencelist on file *)


FROM FileSystem    IMPORT Create, Reset, Close, Response;
FROM TableHandler  IMPORT refarr,refind,treearr,root,treelog;
FROM Command       IMPORT reffileout;
FROM InputOutput   IMPORT ERROR,fileref,PutWord,BlockMark,TreeFlag;
 
EXPORT QUALIFIED OutRef,InvertOrder,now, TermRef;

VAR  order  : ARRAY [0..treelog] OF
                RECORD DownOnPgreater: BOOLEAN;
                  Node: CARDINAL;
                END;
     ordind : INTEGER;    (* index to last order-pointer *)
     now    : CARDINAL;   (* actual file (ref[1] or ref[2]) *)

PROCEDURE InvertOrder(VAR t : CARDINAL);
(* Invert the order of the reference-list beginning with refarr[t].
   t becomes the new begin of the reversed list. *)


VAR  p,q : CARDINAL;

BEGIN
   q:=refarr[t].next;
   refarr[t].next:=0;
   WHILE q # 0 DO
      p:=refarr[q].next;
      refarr[q].next:=t;
      t:=q; q:=p
   END (* WHILE *)
END InvertOrder;

(*-----*)


PROCEDURE OutRef;
    
VAR r,t : CARDINAL;


   PROCEDURE NextId():CARDINAL;
   (* search the next identifier to write on file. Returns Adress of
      node in tree*)


   VAR q : CARDINAL;

   PROCEDURE Through;
   (* change file *)
   BEGIN
      PutWord(now,BlockMark);    (* Write Terminator *)
      IF now=1  THEN now :=2
                ELSE now :=1
      END; (* IF *)
   END Through;


   BEGIN
      q:=treearr[order[ordind].Node].pgreater;
      IF q = 0 THEN  (* no right part *)
         WHILE order[ordind].DownOnPgreater DO DEC(ordind) END;
         IF ordind > 0 THEN DEC(ordind) ELSE Through END;
      ELSE     (* right part *)
         INC(ordind);
         WITH order[ordind] DO DownOnPgreater := TRUE; Node := q END;
         WHILE treearr[q].pless # 0 DO
            q:=treearr[q].pless;
            INC(ordind);
            WITH order[ordind] DO DownOnPgreater := FALSE; Node := q END;
         END  (* WHILE *)
      END;  (* IF *)
      RETURN order[ordind].Node;
   END NextId;

   (*-----*)


   PROCEDURE OpenRef;
   (* create the files ref[1],ref[2],ref[3],ref[4] *)

   VAR i : CARDINAL;

   BEGIN
     FOR i := 1 TO 4 DO
       WITH fileref[i] DO
         Create(file,"DK");
         IF file.res <> done THEN ERROR(7); HALT END;
         Reset(file);
         cnt := 0;
       END; (* WITH *)
     END;
     now:=1
   END OpenRef;

BEGIN (* OutRef *)
   IF NOT reffileout THEN OpenRef END;
   REPEAT
      r:=NextId();      
      t:=treearr[r].pref 
   UNTIL t#0;
   treearr[r].pref:=0;   (* delete reflist in treearr *)
   InvertOrder(t);
   (* Output to file, starting with the address of the treenode *)
   PutWord(now,r+TreeFlag);
   REPEAT
      PutWord(now,refarr[t].rnum);
      (* insert free place in LAVS *)
      r:=refarr[t].next;
      refarr[t].next:=refind;
      refind:=t;
      t:=r
   UNTIL t=0
END OutRef;

  PROCEDURE TermRef;
    VAR ix : CARDINAL;
  BEGIN
    IF reffileout THEN
      FOR ix := 1 TO 4 DO Close(fileref[ix].file) END;
    END;
  END TermRef;

BEGIN  (* RefListOut *)
   ordind:=0;
   WITH order[0] DO DownOnPgreater := FALSE; Node := root END;
END RefListOut;


(*****************************************************)


MODULE MergeFiles;

FROM InputOutput  IMPORT PutWord,GetWord,eorf,BlockMark,TreeFlag,fileref;
FROM TableHandler IMPORT treearr,chlst;
FROM FileSystem   IMPORT Reset, SetOpen;
FROM RefListOut   IMPORT now;

EXPORT QUALIFIED Merge;



PROCEDURE Merge(VAR hlp: CARDINAL);
(* merge and sort the files ref[1] and ref[2]. Result on ref[hlp] *)


VAR w1,w2   : CARDINAL;
    h1      : CARDINAL;
    r1,r2,r3,r4 : CARDINAL;


   PROCEDURE CopyIdList(i : CARDINAL);
   (* i = 1 copy ref[1] to hlp until end-of-block
        = 2 copy ref[2] to hlp until end-of-block
        = 3 copy lower identifier (ref[1] or ref[2]) to hlp *)

   VAR  i1,i2 : CARDINAL;
    

      PROCEDURE CopyPart(rf:CARDINAL;VAR w : CARDINAL);
      BEGIN
         REPEAT
            PutWord(hlp,w);
            GetWord(rf,w)
         UNTIL w >= TreeFlag;
      END CopyPart;

 
      PROCEDURE Lower(k1,k2:CARDINAL):BOOLEAN;
      (* Compare identifier at node k1 with node k2 and 
         Returns id(node k1)<id(node k2)
         assume id(node k1) # id(node k2) *)

      VAR b : BOOLEAN;

      BEGIN
         WHILE chlst[k1] = chlst[k2] DO
            INC(k1);INC(k2)
         END; (* WHILE *)
         IF CAP(chlst[k1])<CAP(chlst[k2]) THEN RETURN TRUE
         ELSIF CAP(chlst[k1])>CAP(chlst[k2]) THEN RETURN FALSE
         ELSE
           (* assume upper case letter greater than lower case letter *)
            b:=chlst[k1]>chlst[k2];
            LOOP
               IF CAP(chlst[k1])#CAP(chlst[k2]) THEN EXIT END;
               IF (chlst[k1]<=' ') AND (chlst[k2]<=' ') THEN RETURN b END;
               INC(k1);INC(k2)
            END;
            RETURN(CAP(chlst[k1])<CAP(chlst[k2]))
         END
      END Lower; 


   BEGIN
      CASE i OF
      1 : (* copy from r1 until end-of-block *)
         WHILE w1 # BlockMark DO
            PutWord(hlp,w1);
            GetWord(r1,w1)
         END; (* WHILE *)
     |2 : (* copy from r2 until end-of-block *)
         WHILE w2 # BlockMark DO
            PutWord(hlp,w2);
            GetWord(r2,w2)
         END; (* WHILE *)
     |3 : (* copy lower id from r1 or r2 *)
         IF w1=w2 THEN (* same identifier *)
            PutWord(hlp,w1);
            GetWord(r1,w1);
            GetWord(r2,w2);
            IF w1 > w2 THEN CopyPart(r2,w2);CopyPart(r1,w1)
                       ELSE CopyPart(r1,w1);CopyPart(r2,w2)
            END; (* IF *)
         ELSE
            i1:=treearr[w1-TreeFlag].pid;
            i2:=treearr[w2-TreeFlag].pid;
            IF Lower(i1,i2) THEN CopyPart(r1,w1);
            ELSE CopyPart(r2,w2);
            END;
         END (* IF *)
      END (* CASE *)
   END CopyIdList;
   
   (*-----*)

   PROCEDURE CopyTwoFiles;

   BEGIN
      (* Reset the files r3 and r4 for overwriteing *)
      Reset(fileref[r3].file);
      Reset(fileref[r4].file);
      fileref[r3].cnt:=0;
      fileref[r4].cnt:=0;
      hlp:=r3;
      WHILE (NOT eorf(r1)) AND (NOT eorf(r2)) DO
         GetWord(r1,w1);
         GetWord(r2,w2);
         REPEAT
            CopyIdList(3)  
         UNTIL (w1=BlockMark) OR (w2=BlockMark);
         CopyIdList(1);
         CopyIdList(2);
         PutWord(hlp,BlockMark);
         IF hlp = r3 THEN hlp:=r4
                     ELSE hlp:=r3 END; 
      END; (* WHILE *)
      IF NOT eorf(r1) THEN
          GetWord(r1,w1);
          CopyIdList(1);
          PutWord(hlp,BlockMark)
      END; (* IF *)
      SetOpen(fileref[r3].file);
      SetOpen(fileref[r4].file);
   END CopyTwoFiles;


BEGIN  (* Merge *)
   PutWord(now,BlockMark);
   Reset(fileref[1].file);
   Reset(fileref[2].file);
   r1:=1; r2:=2; r3:=3; r4:=4;
   WHILE NOT eorf(r2) DO
      CopyTwoFiles;
      h1:=r2;
      r2:=r4;r4:=h1; 
      h1:=r1;
      r1:=r3;r3:=h1;
      Reset(fileref[r1].file);
      Reset(fileref[r2].file);
   END; (* WHILE *)
   hlp:=r1;
END Merge;
END MergeFiles;


(**************************************************)


MODULE Command;


FROM FileSystem   IMPORT
  File, Lookup, Create, Rename, Close, Reset, SetOpen, Response;
FROM FileNames    IMPORT Identifiers, IdentifierPosition;
FROM Options      IMPORT FileNameAndOptions, GetOption, Termination;
FROM Terminal     IMPORT WriteString, WriteLn;
FROM Conversions  IMPORT ConvertCardinal;
FROM RefListOut   IMPORT TermRef;
FROM MergeFiles   IMPORT Merge;
FROM Scanner      IMPORT Scan,first,last;
FROM TableHandler IMPORT WriteTab,treeind,chind,refind;
FROM InputOutput  IMPORT input,output,ERROR;

EXPORT QUALIFIED reffileout;

CONST namelength = 24;
      devicelength = 8;

TYPE FileName = ARRAY [0 .. devicelength + namelength - 1] OF CHAR;
     DeviceName = ARRAY [0 .. devicelength - 1] OF CHAR;

VAR  modName    : FileName;
     lstName    : FileName;
     xrfName    : FileName;
     device     : DeviceName;
     ok         : BOOLEAN;     (* command accepted *)
     reffileout : BOOLEAN;     (* part of table on file fi *)
     i          : CARDINAL;
     fi         : CARDINAL;
     switch,refonline : CARDINAL; (* options *)
     stat       : BOOLEAN;     (* option *)
     extpos     : CARDINAL;
 
   PROCEDURE Statistic;

     TYPE str15 = ARRAY [0..14] OF CHAR;

     VAR numstr : str15;

   BEGIN (* Statistic *)
      WriteString('lines       :  ');
      ConvertCardinal(last-first+1,7,numstr);
      WriteString(numstr);
      WriteLn;
      WriteString('identifiers :  ');
      ConvertCardinal(treeind,7,numstr);
      WriteString(numstr);
      WriteLn;
      WriteString('characters  :  ');
      ConvertCardinal(chind-treeind,7,numstr);
      WriteString(numstr);
      WriteLn;
      WriteString('refnumbers  :  ');
      ConvertCardinal(refind,7,numstr);
      WriteString(numstr);
      WriteLn;
   END Statistic;

   (*-----*)

  PROCEDURE AcceptCommand(VAR fn : FileName; VAR okay: BOOLEAN);
    (* accept command from keyboard *)

    VAR cancel : BOOLEAN;
        termstat : Termination;
        idents : CARDINAL;
        ix : CARDINAL;

    PROCEDURE InterpreteOptions(VAR illegaloptions: BOOLEAN);
      VAR opttext : ARRAY [0..1] OF CHAR;
          optlength : CARDINAL;
    BEGIN
      illegaloptions := FALSE;
      GetOption(opttext,optlength);
      WHILE optlength > 0 DO
        IF optlength <> 1 THEN
          illegaloptions := TRUE;
        ELSE
          CASE opttext[0] OF
            'E'  : refonline := 12
           |'L'  : switch:=0
           |'N'  : switch := 1
           |'S'  : stat := TRUE
          ELSE illegaloptions := TRUE;
          END; (* CASE *)
        END;
        GetOption(opttext,optlength);
      END;
      IF illegaloptions THEN ERROR(5) END;
    END InterpreteOptions;

  BEGIN
    okay := FALSE;
    LOOP
      (* defaults *)
      switch := 2;
      stat := FALSE;
      refonline := 12;
      (* file name and options input *)
      WriteString("input file> ");
      FileNameAndOptions("DK.LST",fn,termstat,TRUE);
      WriteLn;
      IF termstat = normal THEN
        Lookup(input,fn,FALSE);
        IF input.res = done THEN
          InterpreteOptions(cancel);
          IF NOT cancel THEN (* test on device and extension *)
            idents := Identifiers(fn);
            IF idents >= 2 THEN
              extpos := IdentifierPosition(fn,idents - 1);
              ix := 0;
              WHILE (ix <= HIGH(device)) AND (fn[ix] <> '.') DO
                device[ix] := fn[ix];
                INC(ix);
              END;
              IF ix <= HIGH(device) THEN device[ix] := 0C END;
              IF (ix <> 2) OR (device[0] <> 'D') OR (device[1] <> 'K') THEN
                cancel := TRUE;
                WriteString(" ---- illegal device");
                WriteLn;
              END;
            ELSE
              cancel := TRUE;
              WriteString(" ---- extension missing");
              WriteLn;
            END;
          END;
          IF cancel THEN Close(input);
          ELSE
            okay := TRUE;
            EXIT;
          END;
        ELSE
          WriteString(" ---- file not found");
          WriteLn;
        END;
      ELSIF termstat = empty THEN
        WriteString(" ---- no default file");
        WriteLn;
      ELSIF termstat = esc THEN
        EXIT;
      END;
    END; (* LOOP *)
  END AcceptCommand;    

  (*-----*)

  PROCEDURE CreateFile(VAR f: File);
  BEGIN
    Create(f,device);
    IF f.res <> done THEN
      ok := FALSE;
      WriteString(" ---- file creation failed");
      WriteLn;
    END;
  END CreateFile;

  PROCEDURE ReturnFile(f: File);
  BEGIN
    Close(f);
  END ReturnFile;

  PROCEDURE FixName(ext: ARRAY OF CHAR; VAR fname: FileName);
    VAR ix, pos : CARDINAL;
  BEGIN
    ix := 0;
    pos := extpos;
    fname := modName;
    WHILE (ix <= HIGH(ext)) AND (ext[ix] <> 0C) AND
          (pos <= HIGH(fname)) DO
      fname[pos] := ext[ix];
      INC(pos);
      INC(ix);
    END;
    IF pos <= HIGH(fname) THEN fname[pos] := 0C END;
  END FixName;

  PROCEDURE Terminate(VAR f: File; VAR fname: FileName;
                      newfile: BOOLEAN);
    VAR
      old : File;
  BEGIN
    IF newfile  THEN (* lookup for old file *)
      Lookup(old,fname,FALSE);
      IF old.res = done THEN (* purge old file *)
        Rename(old,device);
        Close(old);
      END;
      Rename(f,fname);
      IF f.res <> done THEN
        WriteString(" ---- not catalogued : ");
        WriteString(fname);
        WriteLn;
      END;
    END;
    Close(f);
  END Terminate;

BEGIN  (* Command *)
   reffileout:=FALSE;
   AcceptCommand(modName,ok);
   IF ok THEN
     CreateFile(output);
   END;
   IF ok THEN
     Reset(input);
     Reset(output);
     Scan(switch);
     ReturnFile(input);
     FixName("LST",lstName);
     Terminate(output,lstName,switch = 1);
     CreateFile(output);
   END;
   IF ok THEN
     Reset(output);
     IF reffileout THEN  Merge(fi) END;
     WriteTab(reffileout,fi,refonline);
     IF stat THEN Statistic END;
     FixName("XRF",xrfName);
     Terminate(output,xrfName,TRUE);
     TermRef;
   END;
END Command;

(**************************************************)

END XREF.
